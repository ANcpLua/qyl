using System;
using System.Collections.Frozen;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Context;

#pragma warning disable CA1305, CA1863 // Build-time code generators use invariant formatting

namespace Domain.CodeGen.Generators;

/// <summary>
///     Generates TypeScript type definitions for the dashboard.
///     Produces:
///     - models.ts - Type interfaces matching C# records
///     - api-types.ts - Request/response types for REST API
///     - index.ts - Barrel export
/// </summary>
public sealed class TypeScriptGenerator : IGenerator
{
    const string FileHeader = """
                              // <auto-generated/>
                              // This file was generated by qyl emitter. Do not edit manually.
                              // Generated: {0:O}

                              """;

    public string Name => "TypeScript";

    public FrozenDictionary<string, string> Generate(QylSchema schema, BuildPaths paths, string rootNamespace)
    {
        var outputs = new Dictionary<string, string>();

        // Generate models.ts
        outputs["models.ts"] = EmitModels(schema);

        // Generate api-types.ts
        outputs["api-types.ts"] = EmitApiTypes(schema);

        // Generate index.ts barrel export
        outputs["index.ts"] = EmitIndex();

        return outputs.ToFrozenDictionary();
    }

    // ════════════════════════════════════════════════════════════════════════
    // Models Generation
    // ════════════════════════════════════════════════════════════════════════

    static string EmitModels(QylSchema schema)
    {
        var sb = new StringBuilder();

        sb.AppendFormat(FileHeader, DateTime.UtcNow);
        sb.AppendLine();

        // Primitives as type aliases
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine("// Primitive Types");
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine();

        foreach (var primitive in schema.Primitives)
        {
            var tsType = MapPrimitiveToTypeScript(primitive.UnderlyingType);
            sb.AppendLine($"/** {primitive.Description} */");
            sb.AppendLine($"export type {primitive.Name} = {tsType};");
            sb.AppendLine();
        }

        // Enums
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine("// Enums");
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine();

        foreach (var model in schema.Models.Where(m => m.IsEnum))
        {
            sb.AppendLine($"/** {model.Description} */");
            sb.AppendLine($"export const {model.Name} = {{");

            foreach (var value in model.EnumValues ?? [])
            {
                // Use string values for JSON compatibility
                var tsValue = ToCamelCase(value.Name);
                sb.AppendLine($"  /** {value.Description} */");
                sb.AppendLine($"  {value.Name}: '{tsValue}',");
            }

            sb.AppendLine("} as const;");
            sb.AppendLine();
            sb.AppendLine($"export type {model.Name} = typeof {model.Name}[keyof typeof {model.Name}];");
            sb.AppendLine();
        }

        // Model interfaces
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine("// Model Interfaces");
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine();

        foreach (var model in schema.Models.Where(m => !m.IsEnum))
        {
            sb.AppendLine($"/** {model.Description} */");
            sb.AppendLine($"export interface {model.Name} {{");

            foreach (var prop in model.Properties ?? [])
            {
                var tsType = MapTypeToTypeScript(prop.Type);
                var optional = prop.IsRequired ? "" : "?";
                var jsonName = ToCamelCase(prop.Name);

                sb.AppendLine($"  /** {prop.Description} */");
                sb.AppendLine($"  {jsonName}{optional}: {tsType};");
            }

            sb.AppendLine("}");
            sb.AppendLine();
        }

        // GenAI attributes object
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine("// GenAI Semantic Convention Attributes");
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine();
        sb.AppendLine("/** OpenTelemetry gen_ai.* attribute keys (v1.38) */");
        sb.AppendLine("export const GenAiAttributes = {");

        foreach (var (key, attr) in schema.GenAiAttributes.Where(a => !a.Value.IsDeprecated).OrderBy(a => a.Key))
        {
            var constName = KeyToConstantName(key);
            sb.AppendLine($"  /** {attr.Description} */");
            sb.AppendLine($"  {constName}: '{key}',");
        }

        sb.AppendLine("} as const;");
        sb.AppendLine();

        // Deprecated attributes
        sb.AppendLine("/** Deprecated attribute keys (for migration) */");
        sb.AppendLine("export const DeprecatedGenAiAttributes = {");

        foreach (var (key, attr) in schema.GenAiAttributes.Where(a => a.Value.IsDeprecated).OrderBy(a => a.Key))
        {
            var constName = KeyToConstantName(key);
            sb.AppendLine($"  /** @deprecated Use {attr.ReplacedBy} instead */");
            sb.AppendLine($"  {constName}: '{key}',");
        }

        sb.AppendLine("} as const;");
        sb.AppendLine();

        // Migration map
        sb.AppendLine("/** Maps deprecated attribute keys to their replacements */");
        sb.AppendLine("export const attributeMigrations: Record<string, string> = {");

        foreach (var (key, attr) in schema.GenAiAttributes.Where(a =>
                     a.Value.IsDeprecated && a.Value.ReplacedBy is not null))
            sb.AppendLine($"  '{key}': '{attr.ReplacedBy}',");

        sb.AppendLine("};");
        sb.AppendLine();

        // Helper function
        sb.AppendLine("/** Normalizes a potentially deprecated attribute key to its current equivalent. */");
        sb.AppendLine("export function normalizeAttribute(key: string): string {");
        sb.AppendLine("  return attributeMigrations[key] ?? key;");
        sb.AppendLine("}");

        return sb.ToString();
    }

    // ════════════════════════════════════════════════════════════════════════
    // API Types Generation
    // ════════════════════════════════════════════════════════════════════════

    static string EmitApiTypes(QylSchema schema)
    {
        var sb = new StringBuilder();

        sb.AppendFormat(FileHeader, DateTime.UtcNow);
        sb.AppendLine();
        sb.AppendLine("import type {");
        sb.AppendLine("  SessionId,");
        sb.AppendLine("  TraceId,");
        sb.AppendLine("  SpanRecord,");
        sb.AppendLine("  SessionSummary,");
        sb.AppendLine("  TraceNode,");
        sb.AppendLine("  GenAiSpanData,");
        sb.AppendLine("} from './models';");
        sb.AppendLine();

        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine("// Query Parameters");
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine();

        // Sessions query
        sb.AppendLine("/** Query parameters for GET /api/v1/sessions */");
        sb.AppendLine("export interface SessionsQuery {");
        sb.AppendLine("  /** Filter by service name */");
        sb.AppendLine("  serviceName?: string;");
        sb.AppendLine("  /** Filter sessions starting after this time (ISO 8601) */");
        sb.AppendLine("  from?: string;");
        sb.AppendLine("  /** Filter sessions ending before this time (ISO 8601) */");
        sb.AppendLine("  to?: string;");
        sb.AppendLine("  /** Filter sessions with at least this many tokens */");
        sb.AppendLine("  minTokens?: number;");
        sb.AppendLine("  /** Filter to sessions with errors only */");
        sb.AppendLine("  hasErrors?: boolean;");
        sb.AppendLine("  /** Maximum results to return */");
        sb.AppendLine("  limit?: number;");
        sb.AppendLine("  /** Offset for pagination */");
        sb.AppendLine("  offset?: number;");
        sb.AppendLine("}");
        sb.AppendLine();

        // Spans query
        sb.AppendLine("/** Query parameters for GET /api/v1/spans */");
        sb.AppendLine("export interface SpansQuery {");
        sb.AppendLine("  /** Filter by service name */");
        sb.AppendLine("  serviceName?: string;");
        sb.AppendLine("  /** Filter spans starting after this time (ISO 8601) */");
        sb.AppendLine("  from?: string;");
        sb.AppendLine("  /** Filter spans ending before this time (ISO 8601) */");
        sb.AppendLine("  to?: string;");
        sb.AppendLine("  /** Filter to gen_ai spans only */");
        sb.AppendLine("  genAiOnly?: boolean;");
        sb.AppendLine("  /** Filter by session ID */");
        sb.AppendLine("  sessionId?: SessionId;");
        sb.AppendLine("  /** Filter by trace ID */");
        sb.AppendLine("  traceId?: TraceId;");
        sb.AppendLine("  /** Maximum results to return */");
        sb.AppendLine("  limit?: number;");
        sb.AppendLine("  /** Offset for pagination */");
        sb.AppendLine("  offset?: number;");
        sb.AppendLine("}");
        sb.AppendLine();

        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine("// Response Types");
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine();

        // Sessions response
        sb.AppendLine("/** Response for GET /api/v1/sessions */");
        sb.AppendLine("export interface SessionsResponse {");
        sb.AppendLine("  /** List of sessions */");
        sb.AppendLine("  sessions: SessionSummary[];");
        sb.AppendLine("  /** Total count (for pagination) */");
        sb.AppendLine("  total: number;");
        sb.AppendLine("  /** Whether more results are available */");
        sb.AppendLine("  hasMore: boolean;");
        sb.AppendLine("}");
        sb.AppendLine();

        // Session detail response
        sb.AppendLine("/** Response for GET /api/v1/sessions/{id} */");
        sb.AppendLine("export interface SessionDetailResponse extends SessionSummary {");
        sb.AppendLine("  /** All trace IDs in this session */");
        sb.AppendLine("  traceIds: TraceId[];");
        sb.AppendLine("  /** All spans in this session */");
        sb.AppendLine("  spans: SpanRecord[];");
        sb.AppendLine("}");
        sb.AppendLine();

        // Spans response
        sb.AppendLine("/** Response for GET /api/v1/spans */");
        sb.AppendLine("export interface SpansResponse {");
        sb.AppendLine("  /** List of spans */");
        sb.AppendLine("  spans: SpanRecord[];");
        sb.AppendLine("  /** Total count (for pagination) */");
        sb.AppendLine("  total: number;");
        sb.AppendLine("  /** Whether more results are available */");
        sb.AppendLine("  hasMore: boolean;");
        sb.AppendLine("}");
        sb.AppendLine();

        // Trace response
        sb.AppendLine("/** Response for GET /api/v1/traces/{id} */");
        sb.AppendLine("export interface TraceResponse {");
        sb.AppendLine("  /** Trace tree root */");
        sb.AppendLine("  trace: TraceNode;");
        sb.AppendLine("  /** Total span count in trace */");
        sb.AppendLine("  spanCount: number;");
        sb.AppendLine("  /** Total duration in milliseconds */");
        sb.AppendLine("  durationMs: number;");
        sb.AppendLine("}");
        sb.AppendLine();

        // Statistics
        sb.AppendLine("/** Response for GET /api/v1/sessions/stats */");
        sb.AppendLine("export interface SessionStatisticsResponse {");
        sb.AppendLine("  /** Total session count */");
        sb.AppendLine("  totalSessions: number;");
        sb.AppendLine("  /** Active sessions (recent activity) */");
        sb.AppendLine("  activeSessions: number;");
        sb.AppendLine("  /** Total span count */");
        sb.AppendLine("  totalSpans: number;");
        sb.AppendLine("  /** Total input tokens */");
        sb.AppendLine("  totalInputTokens: number;");
        sb.AppendLine("  /** Total output tokens */");
        sb.AppendLine("  totalOutputTokens: number;");
        sb.AppendLine("  /** Total cost in USD */");
        sb.AppendLine("  totalCostUsd: number;");
        sb.AppendLine("  /** Total tool calls */");
        sb.AppendLine("  totalToolCalls: number;");
        sb.AppendLine("  /** Total errors */");
        sb.AppendLine("  totalErrors: number;");
        sb.AppendLine("  /** Top models by usage */");
        sb.AppendLine("  topModels: Record<string, number>;");
        sb.AppendLine("}");
        sb.AppendLine();

        // SSE events
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine("// SSE Event Types");
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine();

        sb.AppendLine("/** SSE event types */");
        sb.AppendLine("export const SseEventType = {");
        sb.AppendLine("  Connected: 'connected',");
        sb.AppendLine("  Spans: 'spans',");
        sb.AppendLine("  Metrics: 'metrics',");
        sb.AppendLine("  Logs: 'logs',");
        sb.AppendLine("} as const;");
        sb.AppendLine();
        sb.AppendLine("export type SseEventType = typeof SseEventType[keyof typeof SseEventType];");
        sb.AppendLine();

        sb.AppendLine("/** Base SSE event structure */");
        sb.AppendLine("export interface SseEvent<T = unknown> {");
        sb.AppendLine("  /** Event type identifier */");
        sb.AppendLine("  eventType: SseEventType;");
        sb.AppendLine("  /** Event data payload */");
        sb.AppendLine("  data: T;");
        sb.AppendLine("  /** Event timestamp (ISO 8601) */");
        sb.AppendLine("  timestamp: string;");
        sb.AppendLine("}");
        sb.AppendLine();

        sb.AppendLine("/** Typed SSE event for spans */");
        sb.AppendLine("export interface SpansSseEvent extends SseEvent<SpanRecord[]> {");
        sb.AppendLine("  eventType: typeof SseEventType.Spans;");
        sb.AppendLine("}");
        sb.AppendLine();

        // Error response
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine("// Error Types");
        sb.AppendLine("// ═══════════════════════════════════════════════════════════════════════════════");
        sb.AppendLine();

        sb.AppendLine("/** Standard error response */");
        sb.AppendLine("export interface ErrorResponse {");
        sb.AppendLine("  /** Error message */");
        sb.AppendLine("  message: string;");
        sb.AppendLine("  /** Error code */");
        sb.AppendLine("  code?: string;");
        sb.AppendLine("  /** Additional details */");
        sb.AppendLine("  details?: Record<string, unknown>;");
        sb.AppendLine("}");

        return sb.ToString();
    }

    // ════════════════════════════════════════════════════════════════════════
    // Index Export
    // ════════════════════════════════════════════════════════════════════════

    static string EmitIndex()
    {
        var sb = new StringBuilder();

        sb.AppendFormat(FileHeader, DateTime.UtcNow);
        sb.AppendLine();
        sb.AppendLine("// Barrel export for all generated types");
        sb.AppendLine();
        sb.AppendLine("export * from './models';");
        sb.AppendLine("export * from './api-types';");

        return sb.ToString();
    }

    // ════════════════════════════════════════════════════════════════════════
    // Helpers
    // ════════════════════════════════════════════════════════════════════════

    static string MapPrimitiveToTypeScript(string csharpType) =>
        csharpType switch
        {
            "Guid" => "string",
            "ulong" => "string", // JSON can't represent uint64 safely
            "UInt128" => "string",
            "long" => "number",
            "int" => "number",
            "double" => "number",
            "decimal" => "number",
            "bool" => "boolean",
            "string" => "string",
            _ => "unknown"
        };

    static string MapTypeToTypeScript(string csharpType)
    {
        // Handle nullable types
        var isNullable = csharpType.EndsWith('?');
        var baseType = csharpType.TrimEnd('?');

        // Handle generic types
        if (baseType.StartsWith("IReadOnlyList<", StringComparison.Ordinal) && baseType.EndsWith('>'))
        {
            var innerType = baseType[14..^1];
            var tsInner = MapTypeToTypeScript(innerType);
            return $"{tsInner}[]";
        }

        // Map primitive and custom types
        var tsType = baseType switch
        {
            "string" => "string",
            "int" => "number",
            "long" => "number",
            "double" => "number",
            "decimal" => "number",
            "bool" => "boolean",
            "DateTimeOffset" => "string", // ISO 8601
            "DateTime" => "string",
            "Guid" => "string",

            // Custom primitives
            "SessionId" => "SessionId",
            "TraceId" => "TraceId",
            "SpanId" => "SpanId",
            "UnixNano" => "string", // Large numbers as strings

            // Enums
            "SpanKind" => "SpanKind",
            "StatusCode" => "StatusCode",

            // Models
            "GenAiSpanData" => "GenAiSpanData",
            "TraceNode" => "TraceNode",

            _ => baseType // Assume it's a known type
        };

        return isNullable ? $"{tsType} | null" : tsType;
    }

    static string ToCamelCase(string pascalCase)
    {
        if (string.IsNullOrEmpty(pascalCase))
            return pascalCase;

        return char.ToLowerInvariant(pascalCase[0]) + pascalCase[1..];
    }

    static string KeyToConstantName(string key)
    {
        // gen_ai.request.model -> GenAiRequestModel
        var parts = key.Split('.');
        var sb = new StringBuilder();

        foreach (var part in parts)
        {
            if (part.Length is 0) continue;

            var words = part.Split('_');
            foreach (var word in words)
            {
                if (word.Length is 0) continue;
                sb.Append(char.ToUpperInvariant(word[0]));
                sb.Append(word[1..]);
            }
        }

        return sb.ToString();
    }
}