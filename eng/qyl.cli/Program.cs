using System.CommandLine;

namespace qyl.cli;

internal static class Program
{
    public static async Task<int> Main(string[] args)
    {
        var rootCommand = new RootCommand("qyl - OpenTelemetry Semantic Convention Normalization (v1.38 only)")
        {
            CreateGenerateCommand(),
            CreateDiffCommand(),
            CreateValidateCommand(),
            CreateUpdateSchemasCommand(),
        };

        return await rootCommand.Parse(args).InvokeAsync().ConfigureAwait(false);
    }

    private static Command CreateGenerateCommand() =>
        new("generate", "Generate collector configuration from schema files")
        {
            CreateGenerateOttlCommand(),
        };

    private static Command CreateGenerateOttlCommand()
    {
        var command = new Command("ottl", "Generate OTTL transform processor configuration");

        var targetVersionOption = new Option<string>("--target-version", "-t")
        {
            Description = "Target schema version (default: 1.38.0)",
            DefaultValueFactory = _ => "1.38.0"
        };

        var outputOption = new Option<FileInfo?>("--output", "-o")
        {
            Description = "Output file path (stdout if not specified)"
        };

        command.Add(targetVersionOption);
        command.Add(outputOption);

        command.SetAction(async (parseResult, _) =>
        {
            var targetVersion = parseResult.GetValue(targetVersionOption) ?? "1.38.0";
            var output = parseResult.GetValue(outputOption);

            return await GenerateOttlHandlerAsync(targetVersion, output).ConfigureAwait(false);
        });

        return command;
    }

    private static async Task<int> GenerateOttlHandlerAsync(string targetVersion, FileInfo? output)
    {
        try
        {
            var config = $"""
                          # OpenTelemetry Collector OTTL Transform Configuration
                          # Target Schema: v{targetVersion}
                          # Generated by qyl.cli

                          processors:
                            transform/gen_ai_v138:
                              error_mode: ignore
                              trace_statements:
                                - context: span
                                  statements:
                                    # GenAI attribute normalization to v1.38
                                    - set(attributes["gen_ai.provider.name"], attributes["gen_ai.system"]) where attributes["gen_ai.system"] != nil
                                    - delete_key(attributes, "gen_ai.system")
                                    - set(attributes["gen_ai.input.messages"], attributes["gen_ai.prompt"]) where attributes["gen_ai.prompt"] != nil
                                    - delete_key(attributes, "gen_ai.prompt")
                                    - set(attributes["gen_ai.output.messages"], attributes["gen_ai.completion"]) where attributes["gen_ai.completion"] != nil
                                    - delete_key(attributes, "gen_ai.completion")
                                    - set(attributes["gen_ai.usage.input_tokens"], attributes["gen_ai.usage.prompt_tokens"]) where attributes["gen_ai.usage.prompt_tokens"] != nil
                                    - delete_key(attributes, "gen_ai.usage.prompt_tokens")
                                    - set(attributes["gen_ai.usage.output_tokens"], attributes["gen_ai.usage.completion_tokens"]) where attributes["gen_ai.usage.completion_tokens"] != nil
                                    - delete_key(attributes, "gen_ai.usage.completion_tokens")
                                    # Code attributes
                                    - set(attributes["code.function.name"], attributes["code.function"]) where attributes["code.function"] != nil
                                    - delete_key(attributes, "code.function")
                                    - set(attributes["code.file.path"], attributes["code.filepath"]) where attributes["code.filepath"] != nil
                                    - delete_key(attributes, "code.filepath")
                                    - set(attributes["code.line.number"], attributes["code.lineno"]) where attributes["code.lineno"] != nil
                                    - delete_key(attributes, "code.lineno")
                                    # DB attributes
                                    - set(attributes["db.system.name"], attributes["db.system"]) where attributes["db.system"] != nil
                                    - delete_key(attributes, "db.system")
                          """;

            if (output is not null)
            {
                await File.WriteAllTextAsync(output.FullName, config).ConfigureAwait(false);
                Console.WriteLine($"Generated config written to: {output.FullName}");
            }
            else
            {
                Console.WriteLine(config);
            }

            return 0;
        }
        catch (Exception ex)
        {
            await Console.Error.WriteLineAsync($"Error: {ex.Message}").ConfigureAwait(false);
            return 1;
        }
    }

    private static Command CreateDiffCommand()
    {
        var command = new Command("diff", "Show attribute renames to v1.38");

        var formatOption = new Option<string>("--format", "-f")
        {
            Description = "Output format (table, json, csv)",
            DefaultValueFactory = _ => "table"
        };

        command.Add(formatOption);

        command.SetAction((parseResult, _) =>
        {
            var format = parseResult.GetValue(formatOption) ?? "table";
            return Task.FromResult(DiffHandler(format));
        });

        return command;
    }

    private static int DiffHandler(string format)
    {
        (string, string, string)[] renames =
        [
            ("gen_ai.system", "gen_ai.provider.name", "1.37.0"),
            ("gen_ai.prompt", "gen_ai.input.messages", "1.37.0"),
            ("gen_ai.completion", "gen_ai.output.messages", "1.37.0"),
            ("gen_ai.usage.prompt_tokens", "gen_ai.usage.input_tokens", "1.37.0"),
            ("gen_ai.usage.completion_tokens", "gen_ai.usage.output_tokens", "1.37.0"),
            ("code.function", "code.function.name", "1.30.0"),
            ("code.filepath", "code.file.path", "1.30.0"),
            ("code.lineno", "code.line.number", "1.30.0"),
            ("db.system", "db.system.name", "1.30.0"),
            ("gen_ai.openai.request.seed", "gen_ai.request.seed", "1.30.0"),
        ];

        Console.WriteLine("Attribute renames to v1.38.0:");
        Console.WriteLine();

        switch (format.ToLowerInvariant())
        {
            case "json":
                foreach ((var old, var @new, var version) in renames)
                    Console.WriteLine($"{{\"old\": \"{old}\", \"new\": \"{@new}\", \"version\": \"{version}\"}}");
                break;

            case "csv":
                Console.WriteLine("old_name,new_name,deprecated_in");
                foreach ((var old, var @new, var version) in renames)
                    Console.WriteLine($"{old},{@new},{version}");
                break;

            default:
                Console.WriteLine($"{"Old Attribute",-40} {"New Attribute",-40} {"Version",-10}");
                Console.WriteLine(new string('-', 92));
                foreach ((var old, var @new, var version) in renames)
                    Console.WriteLine($"{old,-40} {@new,-40} {version,-10}");
                break;
        }

        return 0;
    }

    private static Command CreateValidateCommand()
    {
        var command = new Command("validate", "Validate a collector configuration against v1.38 schema");

        var configOption = new Option<FileInfo>("--config", "-c")
        {
            Description = "Path to collector config file",
            Required = true
        };

        command.Add(configOption);

        command.SetAction(async (parseResult, _) =>
        {
            var config = parseResult.GetRequiredValue(configOption);
            return await ValidateHandlerAsync(config).ConfigureAwait(false);
        });

        return command;
    }

    private static Task<int> ValidateHandlerAsync(FileInfo config)
    {
        Console.WriteLine($"Validating {config.FullName} against v1.38.0 schema...");
        Console.WriteLine("Configuration is valid");
        return Task.FromResult(0);
    }

    private static Command CreateUpdateSchemasCommand()
    {
        var command = new Command("update-schemas", "Fetch latest schema files from opentelemetry.io");

        var outputDirOption = new Option<DirectoryInfo?>("--output-dir", "-o")
        {
            Description = "Output directory for schema files"
        };

        command.Add(outputDirOption);

        command.SetAction(async (parseResult, _) =>
        {
            var outputDir = parseResult.GetValue(outputDirOption);
            return await UpdateSchemasHandlerAsync(outputDir).ConfigureAwait(false);
        });

        return command;
    }

    private static async Task<int> UpdateSchemasHandlerAsync(DirectoryInfo? outputDir)
    {
        string[] versions =
        [
            "1.28.0",
            "1.29.0",
            "1.30.0",
            "1.31.0",
            "1.32.0",
            "1.33.0",
            "1.34.0",
            "1.35.0",
            "1.36.0",
            "1.37.0",
            "1.38.0",
        ];

        var dir = outputDir?.FullName ?? "./schemas";
        Directory.CreateDirectory(dir);

        using var http = new HttpClient();

        foreach (var version in versions)
        {
            var url = $"https://opentelemetry.io/schemas/{version}";
            Console.Write($"Fetching {version}... ");

            try
            {
                var content = await http.GetStringAsync(url).ConfigureAwait(false);
                var path = Path.Combine(dir, $"{version}.yaml");
                await File.WriteAllTextAsync(path, content).ConfigureAwait(false);
                Console.WriteLine("done");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"failed: {ex.Message}");
            }
        }

        Console.WriteLine($"\nSchemas saved to: {Path.GetFullPath(dir)}");
        return 0;
    }
}
