/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import {
  type Attribute,
  createAttributeFromDiscriminatorValue,
  createInstrumentationScopeFromDiscriminatorValue,
  type InstrumentationScope,
  serializeAttribute,
  serializeInstrumentationScope
} from '../../common/index.js';
// @ts-ignore
import {createResourceFromDiscriminatorValue, type Resource, serializeResource} from '../resource/index.js';
// @ts-ignore
import {
  type AdditionalDataHolder,
  type Parsable,
  type ParseNode,
  type SerializationWriter
} from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SpanEvent}
 */
// @ts-ignore
export function createSpanEventFromDiscriminatorValue(parseNode: ParseNode | undefined): ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
  return deserializeIntoSpanEvent;
}

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Span}
 */
// @ts-ignore
export function createSpanFromDiscriminatorValue(parseNode: ParseNode | undefined): ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
  return deserializeIntoSpan;
}

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SpanLink}
 */
// @ts-ignore
export function createSpanLinkFromDiscriminatorValue(parseNode: ParseNode | undefined): ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
  return deserializeIntoSpanLink;
}

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {SpanStatus}
 */
// @ts-ignore
export function createSpanStatusFromDiscriminatorValue(parseNode: ParseNode | undefined): ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
  return deserializeIntoSpanStatus;
}

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Trace}
 */
// @ts-ignore
export function createTraceFromDiscriminatorValue(parseNode: ParseNode | undefined): ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
  return deserializeIntoTrace;
}

/**
 * The deserialization information for the current model
 * @param Span The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSpan(span: Partial<Span> | undefined = {}): Record<string, (node: ParseNode) => void> {
  return {
    "attributes": n => {
      span.attributes = n.getCollectionOfObjectValues<Attribute>(createAttributeFromDiscriminatorValue);
    },
    "dropped_attributes_count": n => {
      span.droppedAttributesCount = n.getNumberValue();
    },
    "dropped_events_count": n => {
      span.droppedEventsCount = n.getNumberValue();
    },
    "dropped_links_count": n => {
      span.droppedLinksCount = n.getNumberValue();
    },
    "end_time_unix_nano": n => {
      span.endTimeUnixNano = n.getNumberValue();
    },
    "events": n => {
      span.events = n.getCollectionOfObjectValues<SpanEvent>(createSpanEventFromDiscriminatorValue);
    },
    "flags": n => {
      span.flags = n.getNumberValue();
    },
    "instrumentation_scope": n => {
      span.instrumentationScope = n.getObjectValue<InstrumentationScope>(createInstrumentationScopeFromDiscriminatorValue);
    },
    "kind": n => {
      span.kind = n.getNumberValue();
    },
    "links": n => {
      span.links = n.getCollectionOfObjectValues<SpanLink>(createSpanLinkFromDiscriminatorValue);
    },
    "name": n => {
      span.name = n.getStringValue();
    },
    "parent_span_id": n => {
      span.parentSpanId = n.getStringValue();
    },
    "resource": n => {
      span.resource = n.getObjectValue<Resource>(createResourceFromDiscriminatorValue);
    },
    "span_id": n => {
      span.spanId = n.getStringValue();
    },
    "start_time_unix_nano": n => {
      span.startTimeUnixNano = n.getNumberValue();
    },
    "status": n => {
      span.status = n.getObjectValue<SpanStatus>(createSpanStatusFromDiscriminatorValue);
    },
    "trace_id": n => {
      span.traceId = n.getStringValue();
    },
    "trace_state": n => {
      span.traceState = n.getStringValue();
    },
  }
}

/**
 * The deserialization information for the current model
 * @param SpanEvent The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSpanEvent(spanEvent: Partial<SpanEvent> | undefined = {}): Record<string, (node: ParseNode) => void> {
  return {
    "attributes": n => {
      spanEvent.attributes = n.getCollectionOfObjectValues<Attribute>(createAttributeFromDiscriminatorValue);
    },
    "dropped_attributes_count": n => {
      spanEvent.droppedAttributesCount = n.getNumberValue();
    },
    "name": n => {
      spanEvent.name = n.getStringValue();
    },
    "time_unix_nano": n => {
      spanEvent.timeUnixNano = n.getNumberValue();
    },
  }
}

/**
 * The deserialization information for the current model
 * @param SpanLink The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSpanLink(spanLink: Partial<SpanLink> | undefined = {}): Record<string, (node: ParseNode) => void> {
  return {
    "attributes": n => {
      spanLink.attributes = n.getCollectionOfObjectValues<Attribute>(createAttributeFromDiscriminatorValue);
    },
    "dropped_attributes_count": n => {
      spanLink.droppedAttributesCount = n.getNumberValue();
    },
    "flags": n => {
      spanLink.flags = n.getNumberValue();
    },
    "span_id": n => {
      spanLink.spanId = n.getStringValue();
    },
    "trace_id": n => {
      spanLink.traceId = n.getStringValue();
    },
    "trace_state": n => {
      spanLink.traceState = n.getStringValue();
    },
  }
}

/**
 * The deserialization information for the current model
 * @param SpanStatus The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoSpanStatus(spanStatus: Partial<SpanStatus> | undefined = {}): Record<string, (node: ParseNode) => void> {
  return {
    "code": n => {
      spanStatus.code = n.getNumberValue();
    },
    "message": n => {
      spanStatus.message = n.getStringValue();
    },
  }
}

/**
 * The deserialization information for the current model
 * @param Trace The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoTrace(trace: Partial<Trace> | undefined = {}): Record<string, (node: ParseNode) => void> {
  return {
    "duration_ns": n => {
      trace.durationNs = n.getNumberValue();
    },
    "end_time": n => {
      trace.endTime = n.getDateValue();
    },
    "has_error": n => {
      trace.hasError = n.getBooleanValue();
    },
    "root_span": n => {
      trace.rootSpan = n.getObjectValue<Span>(createSpanFromDiscriminatorValue);
    },
    "services": n => {
      trace.services = n.getCollectionOfPrimitiveValues<string>();
    },
    "span_count": n => {
      trace.spanCount = n.getNumberValue();
    },
    "spans": n => {
      trace.spans = n.getCollectionOfObjectValues<Span>(createSpanFromDiscriminatorValue);
    },
    "start_time": n => {
      trace.startTime = n.getDateValue();
    },
    "trace_id": n => {
      trace.traceId = n.getStringValue();
    },
  }
}

/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Span The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSpan(writer: SerializationWriter, span: Partial<Span> | undefined | null = {}, isSerializingDerivedType: boolean = false): void {
  if (!span || isSerializingDerivedType) {
    return;
  }
  writer.writeCollectionOfObjectValues<Attribute>("attributes", span.attributes, serializeAttribute);
  writer.writeNumberValue("dropped_attributes_count", span.droppedAttributesCount);
  writer.writeNumberValue("dropped_events_count", span.droppedEventsCount);
  writer.writeNumberValue("dropped_links_count", span.droppedLinksCount);
  writer.writeNumberValue("end_time_unix_nano", span.endTimeUnixNano);
  writer.writeCollectionOfObjectValues<SpanEvent>("events", span.events, serializeSpanEvent);
  writer.writeNumberValue("flags", span.flags);
  writer.writeObjectValue<InstrumentationScope>("instrumentation_scope", span.instrumentationScope, serializeInstrumentationScope);
  writer.writeNumberValue("kind", span.kind);
  writer.writeCollectionOfObjectValues<SpanLink>("links", span.links, serializeSpanLink);
  writer.writeStringValue("name", span.name);
  writer.writeStringValue("parent_span_id", span.parentSpanId);
  writer.writeObjectValue<Resource>("resource", span.resource, serializeResource);
  writer.writeStringValue("span_id", span.spanId);
  writer.writeNumberValue("start_time_unix_nano", span.startTimeUnixNano);
  writer.writeObjectValue<SpanStatus>("status", span.status, serializeSpanStatus);
  writer.writeStringValue("trace_id", span.traceId);
  writer.writeStringValue("trace_state", span.traceState);
  writer.writeAdditionalData(span.additionalData);
}

/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SpanEvent The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSpanEvent(writer: SerializationWriter, spanEvent: Partial<SpanEvent> | undefined | null = {}, isSerializingDerivedType: boolean = false): void {
  if (!spanEvent || isSerializingDerivedType) {
    return;
  }
  writer.writeCollectionOfObjectValues<Attribute>("attributes", spanEvent.attributes, serializeAttribute);
  writer.writeNumberValue("dropped_attributes_count", spanEvent.droppedAttributesCount);
  writer.writeStringValue("name", spanEvent.name);
  writer.writeNumberValue("time_unix_nano", spanEvent.timeUnixNano);
  writer.writeAdditionalData(spanEvent.additionalData);
}

/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SpanLink The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSpanLink(writer: SerializationWriter, spanLink: Partial<SpanLink> | undefined | null = {}, isSerializingDerivedType: boolean = false): void {
  if (!spanLink || isSerializingDerivedType) {
    return;
  }
  writer.writeCollectionOfObjectValues<Attribute>("attributes", spanLink.attributes, serializeAttribute);
  writer.writeNumberValue("dropped_attributes_count", spanLink.droppedAttributesCount);
  writer.writeNumberValue("flags", spanLink.flags);
  writer.writeStringValue("span_id", spanLink.spanId);
  writer.writeStringValue("trace_id", spanLink.traceId);
  writer.writeStringValue("trace_state", spanLink.traceState);
  writer.writeAdditionalData(spanLink.additionalData);
}

/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param SpanStatus The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeSpanStatus(writer: SerializationWriter, spanStatus: Partial<SpanStatus> | undefined | null = {}, isSerializingDerivedType: boolean = false): void {
  if (!spanStatus || isSerializingDerivedType) {
    return;
  }
  writer.writeNumberValue("code", spanStatus.code);
  writer.writeStringValue("message", spanStatus.message);
  writer.writeAdditionalData(spanStatus.additionalData);
}

/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Trace The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeTrace(writer: SerializationWriter, trace: Partial<Trace> | undefined | null = {}, isSerializingDerivedType: boolean = false): void {
  if (!trace || isSerializingDerivedType) {
    return;
  }
  writer.writeNumberValue("duration_ns", trace.durationNs);
  writer.writeDateValue("end_time", trace.endTime);
  writer.writeBooleanValue("has_error", trace.hasError);
  writer.writeObjectValue<Span>("root_span", trace.rootSpan, serializeSpan);
  writer.writeCollectionOfPrimitiveValues<string>("services", trace.services);
  writer.writeNumberValue("span_count", trace.spanCount);
  writer.writeCollectionOfObjectValues<Span>("spans", trace.spans, serializeSpan);
  writer.writeDateValue("start_time", trace.startTime);
  writer.writeStringValue("trace_id", trace.traceId);
  writer.writeAdditionalData(trace.additionalData);
}

/**
 * OpenTelemetry Span representing a single operation in a distributed trace
 */
export interface Span extends AdditionalDataHolder, Parsable {
  /**
   * Span attributes
   */
  attributes?: Attribute[] | null;
  /**
   * Dropped attributes count
   */
  droppedAttributesCount?: number | null;
  /**
   * Dropped events count
   */
  droppedEventsCount?: number | null;
  /**
   * Dropped links count
   */
  droppedLinksCount?: number | null;
  /**
   * End timestamp in nanoseconds since epoch
   */
  endTimeUnixNano?: number | null;
  /**
   * Span events (logs attached to span)
   */
  events?: SpanEvent[] | null;
  /**
   * Span flags
   */
  flags?: number | null;
  /**
   * Instrumentation scope
   */
  instrumentationScope?: InstrumentationScope | null;
  /**
   * Span kind
   */
  kind?: number | null;
  /**
   * Links to other spans
   */
  links?: SpanLink[] | null;
  /**
   * Human-readable span name
   */
  name?: string | null;
  /**
   * Parent span identifier (null for root spans)
   */
  parentSpanId?: string | null;
  /**
   * Resource describing the entity that produced this span
   */
  resource?: Resource | null;
  /**
   * Unique span identifier (16 hex chars)
   */
  spanId?: string | null;
  /**
   * Start timestamp in nanoseconds since epoch
   */
  startTimeUnixNano?: number | null;
  /**
   * Span status
   */
  status?: SpanStatus | null;
  /**
   * Trace identifier (32 hex chars)
   */
  traceId?: string | null;
  /**
   * W3C trace state
   */
  traceState?: string | null;
}

/**
 * Event occurring during a span's lifetime
 */
export interface SpanEvent extends AdditionalDataHolder, Parsable {
  /**
   * Event attributes
   */
  attributes?: Attribute[] | null;
  /**
   * Dropped attributes count
   */
  droppedAttributesCount?: number | null;
  /**
   * Event name
   */
  name?: string | null;
  /**
   * Event timestamp in nanoseconds since epoch
   */
  timeUnixNano?: number | null;
}

/**
 * Link to another span (e.g., batch processing)
 */
export interface SpanLink extends AdditionalDataHolder, Parsable {
  /**
   * Link attributes
   */
  attributes?: Attribute[] | null;
  /**
   * Dropped attributes count
   */
  droppedAttributesCount?: number | null;
  /**
   * Link flags
   */
  flags?: number | null;
  /**
   * Linked span ID
   */
  spanId?: string | null;
  /**
   * Linked trace ID
   */
  traceId?: string | null;
  /**
   * Trace state of the linked span
   */
  traceState?: string | null;
}

/**
 * Span status
 */
export interface SpanStatus extends AdditionalDataHolder, Parsable {
  /**
   * Status code
   */
  code?: number | null;
  /**
   * Status message (only for ERROR status)
   */
  message?: string | null;
}

/**
 * Complete trace containing all related spans
 */
export interface Trace extends AdditionalDataHolder, Parsable {
  /**
   * Trace duration in nanoseconds
   */
  durationNs?: number | null;
  /**
   * Trace end time
   */
  endTime?: Date | null;
  /**
   * Whether trace contains errors
   */
  hasError?: boolean | null;
  /**
   * Root span of the trace
   */
  rootSpan?: Span | null;
  /**
   * Services involved in this trace
   */
  services?: string[] | null;
  /**
   * Total span count
   */
  spanCount?: number | null;
  /**
   * All spans in this trace
   */
  spans?: Span[] | null;
  /**
   * Trace start time
   */
  startTime?: Date | null;
  /**
   * Trace identifier
   */
  traceId?: string | null;
}

/* tslint:enable */
/* eslint-enable */
