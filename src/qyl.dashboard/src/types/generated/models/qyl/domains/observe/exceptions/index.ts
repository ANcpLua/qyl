/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import {type Attribute, createAttributeFromDiscriminatorValue, serializeAttribute} from '../../../common/index.js';
// @ts-ignore
import {createStackTraceFromDiscriminatorValue, serializeStackTrace, type StackTrace} from '../../aI/code/index.js';
// @ts-ignore
import {
    type AdditionalDataHolder,
    type Parsable,
    type ParseNode,
    type SerializationWriter
} from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {EnrichedException}
 */
// @ts-ignore
export function createEnrichedExceptionFromDiscriminatorValue(parseNode: ParseNode | undefined): ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoEnrichedException;
}

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExceptionServiceStats}
 */
// @ts-ignore
export function createExceptionServiceStatsFromDiscriminatorValue(parseNode: ParseNode | undefined): ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExceptionServiceStats;
}

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExceptionStats}
 */
// @ts-ignore
export function createExceptionStatsFromDiscriminatorValue(parseNode: ParseNode | undefined): ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExceptionStats;
}

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ExceptionTypeStats}
 */
// @ts-ignore
export function createExceptionTypeStatsFromDiscriminatorValue(parseNode: ParseNode | undefined): ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoExceptionTypeStats;
}

/**
 * The deserialization information for the current model
 * @param EnrichedException The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoEnrichedException(enrichedException: Partial<EnrichedException> | undefined = {}): Record<string, (node: ParseNode) => void> {
    return {
        "affected_users": n => {
            enrichedException.affectedUsers = n.getNumberValue();
        },
        "cause": n => {
            enrichedException.cause = n.getObjectValue<EnrichedException>(createEnrichedExceptionFromDiscriminatorValue);
        },
        "data": n => {
            enrichedException.data = n.getCollectionOfObjectValues<Attribute>(createAttributeFromDiscriminatorValue);
        },
        "exception_type": n => {
            enrichedException.exceptionType = n.getStringValue();
        },
        "fingerprint": n => {
            enrichedException.fingerprint = n.getStringValue();
        },
        "first_seen": n => {
            enrichedException.firstSeen = n.getDateValue();
        },
        "last_seen": n => {
            enrichedException.lastSeen = n.getDateValue();
        },
        "message": n => {
            enrichedException.message = n.getStringValue();
        },
        "occurrence_count": n => {
            enrichedException.occurrenceCount = n.getNumberValue();
        },
        "stack_trace": n => {
            enrichedException.stackTrace = n.getObjectValue<StackTrace>(createStackTraceFromDiscriminatorValue);
        },
        "status": n => {
            enrichedException.status = n.getEnumValue<ExceptionStatus>(ExceptionStatusObject);
        },
    }
}

/**
 * The deserialization information for the current model
 * @param ExceptionServiceStats The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoExceptionServiceStats(exceptionServiceStats: Partial<ExceptionServiceStats> | undefined = {}): Record<string, (node: ParseNode) => void> {
    return {
        "count": n => {
            exceptionServiceStats.count = n.getNumberValue();
        },
        "rate_per_minute": n => {
            exceptionServiceStats.ratePerMinute = n.getNumberValue();
        },
        "service_name": n => {
            exceptionServiceStats.serviceName = n.getStringValue();
        },
    }
}

/**
 * The deserialization information for the current model
 * @param ExceptionStats The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoExceptionStats(exceptionStats: Partial<ExceptionStats> | undefined = {}): Record<string, (node: ParseNode) => void> {
    return {
        "by_service": n => {
            exceptionStats.byService = n.getCollectionOfObjectValues<ExceptionServiceStats>(createExceptionServiceStatsFromDiscriminatorValue);
        },
        "by_type": n => {
            exceptionStats.byType = n.getCollectionOfObjectValues<ExceptionTypeStats>(createExceptionTypeStatsFromDiscriminatorValue);
        },
        "total_count": n => {
            exceptionStats.totalCount = n.getNumberValue();
        },
        "trend": n => {
            exceptionStats.trend = n.getEnumValue<ExceptionTrend>(ExceptionTrendObject);
        },
        "unique_types": n => {
            exceptionStats.uniqueTypes = n.getNumberValue();
        },
    }
}

/**
 * The deserialization information for the current model
 * @param ExceptionTypeStats The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoExceptionTypeStats(exceptionTypeStats: Partial<ExceptionTypeStats> | undefined = {}): Record<string, (node: ParseNode) => void> {
    return {
        "count": n => {
            exceptionTypeStats.count = n.getNumberValue();
        },
        "exception_type": n => {
            exceptionTypeStats.exceptionType = n.getStringValue();
        },
        "percentage": n => {
            exceptionTypeStats.percentage = n.getNumberValue();
        },
        "status": n => {
            exceptionTypeStats.status = n.getEnumValue<ExceptionStatus>(ExceptionStatusObject);
        },
    }
}

/**
 * Enriched exception with parsed stack trace
 */
export interface EnrichedException extends AdditionalDataHolder, Parsable {
    /**
     * Affected users count
     */
    affectedUsers?: number | null;
    /**
     * Exception cause/inner exception
     */
    cause?: EnrichedException | null;
    /**
     * Additional exception data
     */
    data?: Attribute[] | null;
    /**
     * Exception type/class name
     */
    exceptionType?: string | null;
    /**
     * Exception fingerprint (for grouping)
     */
    fingerprint?: string | null;
    /**
     * First occurrence timestamp
     */
    firstSeen?: Date | null;
    /**
     * Last occurrence timestamp
     */
    lastSeen?: Date | null;
    /**
     * Exception message
     */
    message?: string | null;
    /**
     * Occurrence count
     */
    occurrenceCount?: number | null;
    /**
     * Parsed stack trace
     */
    stackTrace?: StackTrace | null;
    /**
     * Status
     */
    status?: ExceptionStatus | null;
}

/**
 * Exception stats by service
 */
export interface ExceptionServiceStats extends AdditionalDataHolder, Parsable {
    /**
     * Exception count
     */
    count?: number | null;
    /**
     * Exception rate (per minute)
     */
    ratePerMinute?: number | null;
    /**
     * Service name
     */
    serviceName?: string | null;
}

/**
 * Exception statistics
 */
export interface ExceptionStats extends AdditionalDataHolder, Parsable {
    /**
     * Most affected services
     */
    byService?: ExceptionServiceStats[] | null;
    /**
     * Exceptions by type
     */
    byType?: ExceptionTypeStats[] | null;
    /**
     * Total exception count
     */
    totalCount?: number | null;
    /**
     * Exception trend (up/down/stable)
     */
    trend?: ExceptionTrend | null;
    /**
     * Unique exception types
     */
    uniqueTypes?: number | null;
}

export type ExceptionStatus = (typeof ExceptionStatusObject)[keyof typeof ExceptionStatusObject];
export type ExceptionTrend = (typeof ExceptionTrendObject)[keyof typeof ExceptionTrendObject];

/**
 * Exception stats by type
 */
export interface ExceptionTypeStats extends AdditionalDataHolder, Parsable {
    /**
     * Count
     */
    count?: number | null;
    /**
     * Exception type
     */
    exceptionType?: string | null;
    /**
     * Percentage of total
     */
    percentage?: number | null;
    /**
     * Status
     */
    status?: ExceptionStatus | null;
}

/**
 * Serializes information the current object
 * @param EnrichedException The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeEnrichedException(writer: SerializationWriter, enrichedException: Partial<EnrichedException> | undefined | null = {}, isSerializingDerivedType: boolean = false): void {
    if (!enrichedException || isSerializingDerivedType) {
        return;
    }
    writer.writeNumberValue("affected_users", enrichedException.affectedUsers);
    writer.writeObjectValue<EnrichedException>("cause", enrichedException.cause, serializeEnrichedException);
    writer.writeCollectionOfObjectValues<Attribute>("data", enrichedException.data, serializeAttribute);
    writer.writeStringValue("exception_type", enrichedException.exceptionType);
    writer.writeStringValue("fingerprint", enrichedException.fingerprint);
    writer.writeDateValue("first_seen", enrichedException.firstSeen);
    writer.writeDateValue("last_seen", enrichedException.lastSeen);
    writer.writeStringValue("message", enrichedException.message);
    writer.writeNumberValue("occurrence_count", enrichedException.occurrenceCount);
    writer.writeObjectValue<StackTrace>("stack_trace", enrichedException.stackTrace, serializeStackTrace);
    writer.writeEnumValue<ExceptionStatus>("status", enrichedException.status);
    writer.writeAdditionalData(enrichedException.additionalData);
}

/**
 * Serializes information the current object
 * @param ExceptionServiceStats The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeExceptionServiceStats(writer: SerializationWriter, exceptionServiceStats: Partial<ExceptionServiceStats> | undefined | null = {}, isSerializingDerivedType: boolean = false): void {
    if (!exceptionServiceStats || isSerializingDerivedType) {
        return;
    }
    writer.writeNumberValue("count", exceptionServiceStats.count);
    writer.writeNumberValue("rate_per_minute", exceptionServiceStats.ratePerMinute);
    writer.writeStringValue("service_name", exceptionServiceStats.serviceName);
    writer.writeAdditionalData(exceptionServiceStats.additionalData);
}

/**
 * Serializes information the current object
 * @param ExceptionStats The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeExceptionStats(writer: SerializationWriter, exceptionStats: Partial<ExceptionStats> | undefined | null = {}, isSerializingDerivedType: boolean = false): void {
    if (!exceptionStats || isSerializingDerivedType) {
        return;
    }
    writer.writeCollectionOfObjectValues<ExceptionServiceStats>("by_service", exceptionStats.byService, serializeExceptionServiceStats);
    writer.writeCollectionOfObjectValues<ExceptionTypeStats>("by_type", exceptionStats.byType, serializeExceptionTypeStats);
    writer.writeNumberValue("total_count", exceptionStats.totalCount);
    writer.writeEnumValue<ExceptionTrend>("trend", exceptionStats.trend);
    writer.writeNumberValue("unique_types", exceptionStats.uniqueTypes);
    writer.writeAdditionalData(exceptionStats.additionalData);
}

/**
 * Serializes information the current object
 * @param ExceptionTypeStats The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeExceptionTypeStats(writer: SerializationWriter, exceptionTypeStats: Partial<ExceptionTypeStats> | undefined | null = {}, isSerializingDerivedType: boolean = false): void {
    if (!exceptionTypeStats || isSerializingDerivedType) {
        return;
    }
    writer.writeNumberValue("count", exceptionTypeStats.count);
    writer.writeStringValue("exception_type", exceptionTypeStats.exceptionType);
    writer.writeNumberValue("percentage", exceptionTypeStats.percentage);
    writer.writeEnumValue<ExceptionStatus>("status", exceptionTypeStats.status);
    writer.writeAdditionalData(exceptionTypeStats.additionalData);
}

/**
 * Exception status
 */
export const ExceptionStatusObject = {
    NewEscaped: "new",
    Investigating: "investigating",
    In_progress: "in_progress",
    Resolved: "resolved",
    Ignored: "ignored",
    Regressed: "regressed",
} as const;
/**
 * Exception trend
 */
export const ExceptionTrendObject = {
    Up: "up",
    Down: "down",
    Stable: "stable",
} as const;
/* tslint:enable */
/* eslint-enable */
