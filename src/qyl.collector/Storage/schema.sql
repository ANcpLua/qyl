-- ═══════════════════════════════════════════════════════════════════════════════
-- <auto-generated>
--     This schema was generated by qyl.build (DuckDbGenerator).
--     Do not edit this file manually - changes will be overwritten.
--
--     Source:    eng/build/Domain/CodeGen/QylSchema.cs
--     Generator: DuckDbGenerator
--     Output:    schema.sql
--     Generated: 2026-01-13T01:08:46.8056120Z
-- </auto-generated>
-- ═══════════════════════════════════════════════════════════════════════════════

-- Primary span storage table
CREATE TABLE IF NOT EXISTS spans (
    trace_id VARCHAR NOT NULL, -- Trace ID (32 hex chars)
    span_id VARCHAR NOT NULL, -- Span ID (16 hex chars)
    parent_span_id VARCHAR, -- Parent span ID (null for root spans)
    session_id VARCHAR, -- Session ID for grouping related traces
    name VARCHAR NOT NULL, -- Span name/operation
    service_name VARCHAR, -- Service name from resource attributes
    kind TINYINT NOT NULL, -- Span kind (0=Unspecified, 1=Internal, 2=Server, 3=Client, 4=Producer, 5=Consumer)
    start_time_unix_nano UBIGINT NOT NULL, -- Start time in Unix nanoseconds
    end_time_unix_nano UBIGINT NOT NULL, -- End time in Unix nanoseconds
    status_code TINYINT NOT NULL, -- Status code (0=Unset, 1=Ok, 2=Error)
    status_message VARCHAR, -- Status message (for errors)
    events_json JSON, -- Span events as JSON
    links_json JSON, -- Span links as JSON
    PRIMARY KEY (span_id)
);

CREATE INDEX IF NOT EXISTS idx_spans_trace_id ON spans(trace_id);
CREATE INDEX IF NOT EXISTS idx_spans_service ON spans(service_name);
CREATE INDEX IF NOT EXISTS idx_spans_start_time ON spans(start_time_unix_nano DESC);
CREATE INDEX IF NOT EXISTS idx_spans_session ON spans(session_id);

-- Materialized view for session aggregation
CREATE OR REPLACE VIEW sessions_agg AS
SELECT
    COALESCE(session_id, trace_id) as session_id,
    service_name as service_name,
    MIN(start_time_unix_nano) as start_time,
    MAX(end_time_unix_nano) as end_time,
    COUNT(*) as span_count,
    COUNT(*) as gen_ai_span_count,
    0 as total_input_tokens,
    0 as total_output_tokens,
    COUNT(DISTINCT trace_id) as trace_count,
    COUNT(*) FILTER (WHERE status_code = 2) as error_count,
    NULL as primary_provider,
    NULL as primary_model
FROM spans
GROUP BY COALESCE(session_id, trace_id), service_name;

