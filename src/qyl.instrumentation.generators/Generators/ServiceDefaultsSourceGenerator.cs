using System.Collections.Immutable;
using ANcpLua.Roslyn.Utilities;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Operations;

namespace qyl.instrumentation.generators.Generators;

[Generator]
public sealed class ServiceDefaultsSourceGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var hasServiceDefaults = context.CompilationProvider
            .Select(HasServiceDefaultsType)
            .WithTrackingName(TrackingNames.ServiceDefaultsAvailable);

        var interceptionCandidates = context.SyntaxProvider
            .CreateSyntaxProvider(IsPotentialBuildCall, TransformToBuildInterception)
            .SelectMany(AsSingletonOrEmpty)
            .WithTrackingName(TrackingNames.InterceptionCandidates)
            .Collect()
            .WithTrackingName(TrackingNames.CollectedBuildCalls);

        context.RegisterSourceOutput(
            interceptionCandidates.Combine(hasServiceDefaults),
            EmitInterceptors);
    }

    private static bool HasServiceDefaultsType(Compilation compilation, CancellationToken _) => 
        compilation.GetTypeByMetadataName(MetadataNames.ServiceDefaultsClass) is not null;

    private static bool IsPotentialBuildCall(SyntaxNode node, CancellationToken _) => 
        node.IsKind(SyntaxKind.InvocationExpression);

    private static ImmutableArray<InterceptionData> AsSingletonOrEmpty(InterceptionData? item, CancellationToken _) =>
        item is not null ? [item] : [];

    private static InterceptionData? TransformToBuildInterception(GeneratorSyntaxContext context, CancellationToken ct)
    {
        if (context.SemanticModel.GetOperation(context.Node, ct) is not IInvocationOperation invocation) return null;
        if (!IsBuildMethod(invocation, context.SemanticModel.Compilation)) return null;
        if (GetInterceptableLocation(context, ct) is not { } location) return null;

        return new InterceptionData
        {
            OrderKey = FormatLocationKey(context.Node),
            InterceptableLocation = location
        };
    }

    private static bool IsBuildMethod(IInvocationOperation invocation, Compilation compilation) =>
        invocation.TargetMethod.Name == MethodNames.Build &&
        SymbolEqualityComparer.Default.Equals(
            invocation.TargetMethod.ContainingType, 
            compilation.GetTypeByMetadataName(MetadataNames.WebApplicationBuilder));

    private static InterceptableLocation? GetInterceptableLocation(GeneratorSyntaxContext context, CancellationToken ct) =>
        context.SemanticModel.GetInterceptableLocation((InvocationExpressionSyntax)context.Node, ct);

    private static string FormatLocationKey(SyntaxNode node)
    {
        var pos = node.GetLocation().GetLineSpan().StartLinePosition;
        return $"{node.SyntaxTree.FilePath}:{pos.Line}:{pos.Character}";
    }

    private static void EmitInterceptors(
        SourceProductionContext context,
        (ImmutableArray<InterceptionData> Candidates, bool HasServiceDefaults) source)
    {
        if (!source.HasServiceDefaults || source.Candidates.IsDefaultOrEmpty) return;

        var code = GenerateInterceptorCode(source.Candidates);
        context.AddSource(OutputFileNames.Interceptors, code);
    }

    private static string GenerateInterceptorCode(ImmutableArray<InterceptionData> candidates)
    {
        var sb = new IndentedStringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Runtime.CompilerServices;");
        sb.AppendLine("using Microsoft.AspNetCore.Builder;");
        sb.AppendLine("using qyl.instrumentation;");
        sb.AppendLine();

        using (sb.BeginNamespace("qyl.instrumentation.AutoRegister"))
        {
            using (sb.BeginClass("internal static", "Interceptors"))
            {
                foreach (var candidate in candidates)
                {
                    var (version, data) = (candidate.InterceptableLocation.Version, candidate.InterceptableLocation.Data);
                    sb.AppendLine($"[InterceptsLocation({version}, \"{data}\")]");
                }

                using (sb.BeginMethod("public static", "WebApplication", "InterceptBuild", "this WebApplicationBuilder builder"))
                {
                    sb.AppendLine("builder.AddServiceDefaults();");
                    sb.AppendLine("var app = builder.Build();");
                    sb.AppendLine("app.MapServiceDefaults();");
                    sb.AppendLine("return app;");
                }
            }
        }

        sb.AppendLine();
        using (sb.BeginNamespace("System.Runtime.CompilerServices"))
        {
            sb.AppendLine("[AttributeUsage(AttributeTargets.Method, AllowMultiple = true)]");
            sb.AppendLine("internal sealed class InterceptsLocationAttribute(int version, string data) : Attribute;");
        }

        return sb.ToString();
    }
}

internal sealed class InterceptionData
{
    public required string OrderKey { get; init; }
    public required InterceptableLocation InterceptableLocation { get; init; }
}
