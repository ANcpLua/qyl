// =============================================================================
// qyl.instrumentation.generators - GenAI Interceptor Generator
// Compile-time auto-instrumentation using C# interceptors
// Owner: qyl.instrumentation.generators
// =============================================================================

using System.Collections.Immutable;
using ANcpLua.Roslyn.Utilities;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using qyl.instrumentation.generators.Emitters;

namespace qyl.instrumentation.generators.Interceptors;

/// <summary>
///     Source generator that creates interceptors for GenAI/LLM calls.
///     Architecture:
///     - Interception = HOW you capture data (interceptors wrap method calls)
///     - Semantic conventions = WHAT you capture (OTel GenAI semconv from qyl.protocol)
///     Interceptor Limitations (be honest):
///     - Cannot instrument interface calls (IOpenAiClient.Chat)
///     - Cannot instrument virtual dispatch (base class calls)
///     - Cannot instrument compiled packages (only YOUR source code)
///     What OTel libraries already do (don't reinvent):
///     - HTTP client/server, Database, gRPC, Runtime metrics
///     What this generator covers (gaps OTel doesn't fill):
///     - GenAI/LLM SDK calls (OpenAI, Anthropic, Ollama, Azure AI)
/// </summary>
[Generator]
public sealed class GenAiInterceptorGenerator : IIncrementalGenerator
{
    private const string ConfigSource = """
                                        // <auto-generated/>
                                        // Generated by qyl.instrumentation.generators

                                        namespace qyl.instrumentation;

                                        /// <summary>
                                        /// Configuration for GenAI auto-instrumentation.
                                        /// </summary>
                                        public static class GenAiInstrumentationConfig
                                        {
                                            /// <summary>
                                            /// ActivitySource name for GenAI spans.
                                            /// Add to your OTel configuration:
                                            /// <code>
                                            /// builder.Services.AddOpenTelemetry()
                                            ///     .WithTracing(t => t.AddSource(GenAiInstrumentationConfig.ActivitySourceName));
                                            /// </code>
                                            /// </summary>
                                            public const string ActivitySourceName = "qyl.instrumentation.GenAi";

                                            /// <summary>OTel schema version.</summary>
                                            public const string SchemaUrl = "https://opentelemetry.io/schemas/1.39.0";
                                        }
                                        """;

    // Target methods we know how to instrument
    // Provider values: OTel semconv 1.39 (see qyl.protocol.Attributes.GenAiAttributes.Providers)
    // QYL extensions: "ollama" (not in OTel semconv)
    private static readonly Dictionary<string, GenAiTarget> KnownTargets = new()
    {
        // OTel semconv 1.39 providers
        ["OpenAI.Chat.ChatClient.CompleteChatAsync"] = new GenAiTarget("openai", "chat", "chat {gen_ai.request.model}"),
        ["OpenAI.Chat.ChatClient.CompleteChat"] = new GenAiTarget("openai", "chat", "chat {gen_ai.request.model}"),
        ["Anthropic.AnthropicClient.CreateMessageAsync"] =
            new GenAiTarget("anthropic", "chat", "chat {gen_ai.request.model}"),
        ["Anthropic.Messages.MessageClient.CreateAsync"] =
            new GenAiTarget("anthropic", "chat", "chat {gen_ai.request.model}"),
        ["Azure.AI.Inference.ChatCompletionsClient.CompleteAsync"] =
            new GenAiTarget("azure.ai.inference", "chat", "chat {gen_ai.request.model}"),

        // QYL extension providers (not in OTel semconv)
        ["OllamaSharp.OllamaApiClient.ChatAsync"] = new GenAiTarget("ollama", "chat", "chat {gen_ai.request.model}")
    };

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Find all method invocations that match our targets
        var invocations = context.SyntaxProvider
            .CreateSyntaxProvider(
                static (node, _) => node is InvocationExpressionSyntax,
                static (ctx, ct) => GetInterceptTarget(ctx, ct))
            .WhereNotNull();

        // Collect and emit
        context.RegisterSourceOutput(
            invocations.CollectAsEquatableArray(),
            static (spc, targets) => Execute(spc, targets));

        // Always emit the configuration source
        context.RegisterPostInitializationOutput(static ctx =>
        {
            ctx.AddSource("GenAiInstrumentationConfig.g.cs", SourceText.From(ConfigSource, Encoding.UTF8));
        });
    }

    private static InterceptorTarget? GetInterceptTarget(
        GeneratorSyntaxContext ctx,
        CancellationToken ct)
    {
        var invocation = (InvocationExpressionSyntax)ctx.Node;

        if (ctx.SemanticModel.GetSymbolInfo(invocation, ct).Symbol is not IMethodSymbol method)
            return null;

        var containingType = method.ContainingType?.ToDisplayString() ?? "";
        var key = $"{containingType}.{method.Name}";

        if (!KnownTargets.TryGetValue(key, out var target))
            return null;

        var location = invocation.GetLocation();
        var lineSpan = location.GetLineSpan();

        var parameters = method.Parameters
            .Select(static p => new ParameterInfo(p.Type.ToDisplayString(), p.Name))
            .ToArray();

        return new InterceptorTarget(
            lineSpan.Path,
            lineSpan.StartLinePosition.Line + 1,
            lineSpan.StartLinePosition.Character + 1,
            containingType,
            method.Name,
            method.ReturnType.ToDisplayString(),
            target.Provider,
            target.Operation,
            target.SpanNameTemplate,
            parameters);
    }

    private static void Execute(
        SourceProductionContext context,
        EquatableArray<InterceptorTarget> targets)
    {
        if (targets.IsEmpty)
            return;

        var source = InterceptorEmitter.Emit(targets.AsImmutableArray());
        context.AddSource("GenAiInterceptors.g.cs", SourceText.From(source, Encoding.UTF8));
    }
}

internal readonly record struct GenAiTarget(string Provider, string Operation, string SpanNameTemplate);

internal readonly record struct ParameterInfo(string Type, string Name);

/// <summary>
///     Target for interceptor code generation.
/// </summary>
internal readonly record struct InterceptorTarget(
    string FilePath,
    int Line,
    int Column,
    string ContainingType,
    string MethodName,
    string ReturnType,
    string Provider,
    string Operation,
    string SpanNameTemplate,
    IReadOnlyList<ParameterInfo> Parameters);
