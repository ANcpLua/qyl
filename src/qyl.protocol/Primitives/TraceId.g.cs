// <auto-generated>
//     This code was generated by qyl.build (CSharpGenerator).
//     Do not edit this file manually - changes will be overwritten.
//
//     Source:    eng/build/Domain/CodeGen/QylSchema.cs
//     Generator: CSharpGenerator
//     Output:    Primitives/TraceId.g.cs
//     Generated: 2025-12-17T23:31:13.7119780Z
// </auto-generated>

#nullable enable

using System;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace qyl.protocol.Primitives;

/// <summary>
/// 128-bit trace identifier (OTel W3C format)
/// </summary>
public readonly partial struct TraceId : ISpanParsable<TraceId>, IEquatable<TraceId>, IComparable<TraceId>, IFormattable
{
    private readonly UInt128 _value;

    /// <summary>Creates a new <see cref="TraceId"/> from the underlying value.</summary>
    public TraceId(UInt128 value) => _value = value;

    /// <summary>Gets the underlying UInt128 value.</summary>
    public UInt128 Value => _value;

    /// <summary>Gets the default (empty) value.</summary>
    public static TraceId Empty => new(UInt128.Zero);

    /// <summary>Implicitly converts to the underlying type.</summary>
    public static implicit operator UInt128(TraceId value) => value._value;

    /// <summary>Explicitly converts from the underlying type.</summary>
    public static explicit operator TraceId(UInt128 value) => new(value);

    /// <inheritdoc/>
    public bool Equals(TraceId other) => _value.Equals(other._value);

    /// <inheritdoc/>
    public override bool Equals([NotNullWhen(true)] object? obj) => obj is TraceId other && Equals(other);

    /// <inheritdoc/>
    public override int GetHashCode() => _value.GetHashCode();

    /// <inheritdoc/>
    public int CompareTo(TraceId other) => _value.CompareTo(other._value);

    /// <summary>Equality operator.</summary>
    public static bool operator ==(TraceId left, TraceId right) => left.Equals(right);

    /// <summary>Inequality operator.</summary>
    public static bool operator !=(TraceId left, TraceId right) => !left.Equals(right);

    /// <inheritdoc/>
    public override string ToString() => _value.ToString("x32");

    /// <inheritdoc/>
    public string ToString(string? format, IFormatProvider? formatProvider) => _value.ToString(format, formatProvider);

    /// <summary>Parses a span of characters into a <see cref="TraceId"/>.</summary>
    public static TraceId Parse(ReadOnlySpan<char> s, IFormatProvider? provider = null)
        => new(UInt128.Parse(s, NumberStyles.HexNumber, provider));

    /// <summary>Tries to parse a span of characters into a <see cref="TraceId"/>.</summary>
    public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out TraceId result)
    {
        if (UInt128.TryParse(s, NumberStyles.HexNumber, provider, out var value))
        {
            result = new TraceId(value);
            return true;
        }
        result = Empty;
        return false;
    }

    /// <summary>Parses a string into a <see cref="TraceId"/>.</summary>
    public static TraceId Parse(string s, IFormatProvider? provider = null)
        => Parse(s.AsSpan(), provider);

    /// <summary>Tries to parse a string into a <see cref="TraceId"/>.</summary>
    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out TraceId result)
    {
        if (s is null)
        {
            result = Empty;
            return false;
        }
        return TryParse(s.AsSpan(), provider, out result);
    }

    /// <summary>Returns true if this is the default/empty value.</summary>
    public bool IsEmpty => _value == UInt128.Zero;

    /// <summary>Gets the zero value.</summary>
    public static readonly TraceId Zero = Empty;

    /// <summary>Tries to format the value into the provided span.</summary>
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default, IFormatProvider? provider = null)
    {
        return _value.TryFormat(destination, out charsWritten, "x32", provider);
    }

    /// <summary>Parses a UTF-8 span into this type.</summary>
    public static TraceId Parse(ReadOnlySpan<byte> utf8)
    {
        Span<char> chars = stackalloc char[utf8.Length];
        for (int i = 0; i < utf8.Length; i++) chars[i] = (char)utf8[i];
        return Parse(chars);
    }

    /// <summary>Tries to parse a UTF-8 span into this type.</summary>
    public static bool TryParse(ReadOnlySpan<byte> utf8, out TraceId result)
    {
        Span<char> chars = stackalloc char[utf8.Length];
        for (int i = 0; i < utf8.Length; i++) chars[i] = (char)utf8[i];
        return TryParse(chars, null, out result);
    }

    /// <summary>Tries to parse a UTF-8 span into this type (IFormatProvider overload for compatibility).</summary>
    public static bool TryParse(ReadOnlySpan<byte> utf8, IFormatProvider? provider, out TraceId result)
        => TryParse(utf8, out result);

}
