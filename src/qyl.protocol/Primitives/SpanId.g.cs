// <auto-generated>
//     This code was generated by qyl.build (CSharpGenerator).
//     Do not edit this file manually - changes will be overwritten.
//
//     Source:    eng/build/Domain/CodeGen/QylSchema.cs
//     Generator: CSharpGenerator
//     Output:    Primitives/SpanId.g.cs
//     Generated: 2025-12-17T23:31:13.7119850Z
// </auto-generated>

#nullable enable

using System;
using System.Diagnostics.CodeAnalysis;
using System.Globalization;
using System.Text.Json;
using System.Text.Json.Serialization;

namespace qyl.protocol.Primitives;

/// <summary>
/// 64-bit span identifier
/// </summary>
public readonly partial struct SpanId : ISpanParsable<SpanId>, IEquatable<SpanId>, IComparable<SpanId>, IFormattable
{
    private readonly ulong _value;

    /// <summary>Creates a new <see cref="SpanId"/> from the underlying value.</summary>
    public SpanId(ulong value) => _value = value;

    /// <summary>Gets the underlying ulong value.</summary>
    public ulong Value => _value;

    /// <summary>Gets the default (empty) value.</summary>
    public static SpanId Empty => new(0UL);

    /// <summary>Implicitly converts to the underlying type.</summary>
    public static implicit operator ulong(SpanId value) => value._value;

    /// <summary>Explicitly converts from the underlying type.</summary>
    public static explicit operator SpanId(ulong value) => new(value);

    /// <inheritdoc/>
    public bool Equals(SpanId other) => _value.Equals(other._value);

    /// <inheritdoc/>
    public override bool Equals([NotNullWhen(true)] object? obj) => obj is SpanId other && Equals(other);

    /// <inheritdoc/>
    public override int GetHashCode() => _value.GetHashCode();

    /// <inheritdoc/>
    public int CompareTo(SpanId other) => _value.CompareTo(other._value);

    /// <summary>Equality operator.</summary>
    public static bool operator ==(SpanId left, SpanId right) => left.Equals(right);

    /// <summary>Inequality operator.</summary>
    public static bool operator !=(SpanId left, SpanId right) => !left.Equals(right);

    /// <inheritdoc/>
    public override string ToString() => _value.ToString("x16");

    /// <inheritdoc/>
    public string ToString(string? format, IFormatProvider? formatProvider) => _value.ToString(format, formatProvider);

    /// <summary>Parses a span of characters into a <see cref="SpanId"/>.</summary>
    public static SpanId Parse(ReadOnlySpan<char> s, IFormatProvider? provider = null)
        => new(ulong.Parse(s, NumberStyles.HexNumber, provider));

    /// <summary>Tries to parse a span of characters into a <see cref="SpanId"/>.</summary>
    public static bool TryParse(ReadOnlySpan<char> s, IFormatProvider? provider, out SpanId result)
    {
        if (ulong.TryParse(s, NumberStyles.HexNumber, provider, out var value))
        {
            result = new SpanId(value);
            return true;
        }
        result = Empty;
        return false;
    }

    /// <summary>Parses a string into a <see cref="SpanId"/>.</summary>
    public static SpanId Parse(string s, IFormatProvider? provider = null)
        => Parse(s.AsSpan(), provider);

    /// <summary>Tries to parse a string into a <see cref="SpanId"/>.</summary>
    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, out SpanId result)
    {
        if (s is null)
        {
            result = Empty;
            return false;
        }
        return TryParse(s.AsSpan(), provider, out result);
    }

    /// <summary>Returns true if this is the default/empty value.</summary>
    public bool IsEmpty => _value == 0UL;

    /// <summary>Gets the zero value.</summary>
    public static readonly SpanId Zero = Empty;

    /// <summary>Tries to format the value into the provided span.</summary>
    public bool TryFormat(Span<char> destination, out int charsWritten, ReadOnlySpan<char> format = default, IFormatProvider? provider = null)
    {
        return _value.TryFormat(destination, out charsWritten, "x16", provider);
    }

    /// <summary>Parses a UTF-8 span into this type.</summary>
    public static SpanId Parse(ReadOnlySpan<byte> utf8)
    {
        Span<char> chars = stackalloc char[utf8.Length];
        for (int i = 0; i < utf8.Length; i++) chars[i] = (char)utf8[i];
        return Parse(chars);
    }

    /// <summary>Tries to parse a UTF-8 span into this type.</summary>
    public static bool TryParse(ReadOnlySpan<byte> utf8, out SpanId result)
    {
        Span<char> chars = stackalloc char[utf8.Length];
        for (int i = 0; i < utf8.Length; i++) chars[i] = (char)utf8[i];
        return TryParse(chars, null, out result);
    }

    /// <summary>Tries to parse a UTF-8 span into this type (IFormatProvider overload for compatibility).</summary>
    public static bool TryParse(ReadOnlySpan<byte> utf8, IFormatProvider? provider, out SpanId result)
        => TryParse(utf8, out result);

}
