using System.Collections.Immutable;
using System.Text;
using Qyl.ServiceDefaults.Generator.Models;
using Microsoft.CodeAnalysis.CSharp;

namespace Qyl.ServiceDefaults.Generator.Emitters;

/// <summary>
///     Emits interceptor source code for GenAI SDK method invocations.
/// </summary>
/// <remarks>
///     Uses <see cref="ProviderRegistry" /> as the Single Source of Truth for provider definitions.
/// </remarks>
internal static class GenAiInterceptorEmitter
{
    /// <summary>
    ///     Emits the interceptor source code for all GenAI invocations.
    /// </summary>
    public static string Emit(ImmutableArray<GenAiInvocationInfo> invocations)
    {
        if (invocations.IsEmpty)
            return string.Empty;

        var sb = new StringBuilder();

        AppendFileHeader(sb);
        AppendUsings(sb);
        AppendInterceptsLocationAttribute(sb);
        AppendClassOpen(sb);
        AppendInterceptorMethods(sb, invocations);
        AppendClassClose(sb);

        return sb.ToString();
    }

    private static void AppendFileHeader(StringBuilder sb)
    {
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#pragma warning disable");
        sb.AppendLine();
    }

    private static void AppendInterceptsLocationAttribute(StringBuilder sb)
    {
        sb.AppendLine("""
                      namespace System.Runtime.CompilerServices
                      {
                          [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                          file sealed class InterceptsLocationAttribute(int version, string data) : global::System.Attribute;
                      }
                      """);
        sb.AppendLine();
    }

    private static void AppendUsings(StringBuilder sb)
    {
        sb.AppendLine("using System.Diagnostics;");
        sb.AppendLine("using Qyl.ServiceDefaults.Instrumentation;");
        sb.AppendLine("using Qyl.ServiceDefaults.Instrumentation.GenAi;");
        sb.AppendLine();
    }

    private static void AppendClassOpen(StringBuilder sb)
    {
        sb.AppendLine("""
                      namespace Qyl.ServiceDefaults.Generator
                      {
                          file static class GenAiInterceptors
                          {
                      """);
    }

    private static void AppendInterceptorMethods(
        StringBuilder sb,
        ImmutableArray<GenAiInvocationInfo> invocations)
    {
        var orderedInvocations = invocations
            .OrderBy(static i => i.OrderKey, StringComparer.Ordinal);

        var index = 0;
        foreach (var invocation in orderedInvocations)
        {
            AppendSingleInterceptor(sb, invocation, index);
            index++;
        }
    }

    private static void AppendSingleInterceptor(
        StringBuilder sb,
        GenAiInvocationInfo invocation,
        int index)
    {
        var displayLocation = invocation.InterceptableLocation.GetDisplayLocation();
        var interceptAttribute = invocation.InterceptableLocation.GetInterceptsLocationAttributeSyntax();

        var methodName = $"Intercept_GenAi_{index}";
        var returnType = invocation.ReturnTypeName;
        var containingType = invocation.ContainingTypeName;
        var originalMethod = invocation.MethodName;

        var parameters = BuildParameterList(invocation, containingType);
        var arguments = BuildArgumentList(invocation);

        var modelArg = invocation.Model is not null
            ? $"\"{invocation.Model}\""
            : "null";

        var usageExtractor = GetUsageExtractor(invocation.Provider, invocation.Operation);

        if (invocation.IsAsync)
        {
            sb.AppendLine(usageExtractor is not null
                ? $$"""
                            // Intercepted call at {{displayLocation}}
                            {{interceptAttribute}}
                            public static async {{returnType}} {{methodName}}({{parameters}})
                            {
                                return await GenAiInstrumentation.ExecuteAsync(
                                    "{{invocation.Provider}}",
                                    "{{invocation.Operation}}",
                                    {{modelArg}},
                                    async () => await @this.{{originalMethod}}({{arguments}}),
                                    {{usageExtractor}});
                            }

                    """
                : $$"""
                            // Intercepted call at {{displayLocation}}
                            {{interceptAttribute}}
                            public static async {{returnType}} {{methodName}}({{parameters}})
                            {
                                return await GenAiInstrumentation.ExecuteAsync(
                                    "{{invocation.Provider}}",
                                    "{{invocation.Operation}}",
                                    {{modelArg}},
                                    async () => await @this.{{originalMethod}}({{arguments}}));
                            }

                    """);
        }
        else
        {
            sb.AppendLine(usageExtractor is not null
                ? $$"""
                            // Intercepted call at {{displayLocation}}
                            {{interceptAttribute}}
                            public static {{returnType}} {{methodName}}({{parameters}})
                            {
                                return GenAiInstrumentation.Execute(
                                    "{{invocation.Provider}}",
                                    "{{invocation.Operation}}",
                                    {{modelArg}},
                                    () => @this.{{originalMethod}}({{arguments}}),
                                    {{usageExtractor}});
                            }

                    """
                : $$"""
                            // Intercepted call at {{displayLocation}}
                            {{interceptAttribute}}
                            public static {{returnType}} {{methodName}}({{parameters}})
                            {
                                return GenAiInstrumentation.Execute(
                                    "{{invocation.Provider}}",
                                    "{{invocation.Operation}}",
                                    {{modelArg}},
                                    () => @this.{{originalMethod}}({{arguments}}));
                            }

                    """);
        }
    }

    /// <summary>
    ///     Gets the usage extractor lambda for a provider/operation combination.
    ///     Uses ProviderRegistry as the SSOT.
    /// </summary>
    private static string? GetUsageExtractor(string provider, string operation)
    {
        var definition = ProviderRegistry.GenAiProviders
            .FirstOrDefault(p => p.ProviderId == provider);

        if (definition?.TokenUsage is null)
            return null;

        if (operation != "chat" && operation != "embeddings")
            return null;

        var usage = definition.TokenUsage;
        var outputTokens = operation == "embeddings" ? "0" : $"r.{usage.OutputProperty}";

        return $"static r => new TokenUsage(r.{usage.InputProperty}, {outputTokens})";
    }

    private static string BuildParameterList(GenAiInvocationInfo invocation, string containingType)
    {
        var sb = new StringBuilder();
        sb.Append($"this global::{containingType} @this");

        for (var i = 0; i < invocation.ParameterTypes.Count; i++)
            sb.Append($", global::{invocation.ParameterTypes[i]} arg{i}");

        return sb.ToString();
    }

    private static string BuildArgumentList(GenAiInvocationInfo invocation)
    {
        if (invocation.ParameterTypes.Count == 0)
            return string.Empty;

        var args = new string[invocation.ParameterTypes.Count];
        for (var i = 0; i < invocation.ParameterTypes.Count; i++)
            args[i] = $"arg{i}";

        return string.Join(", ", args);
    }

    private static void AppendClassClose(StringBuilder sb)
    {
        sb.AppendLine("""
                          }
                      }
                      """);
    }
}
