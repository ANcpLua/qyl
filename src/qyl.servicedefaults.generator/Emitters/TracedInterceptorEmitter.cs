using System.Collections.Immutable;
using System.Text;
using Qyl.ServiceDefaults.Generator.Models;
using Microsoft.CodeAnalysis.CSharp;

namespace Qyl.ServiceDefaults.Generator.Emitters;

/// <summary>
///     Emits interceptor source code for methods decorated with [Traced] attribute.
/// </summary>
internal static class TracedInterceptorEmitter
{
    /// <summary>
    ///     Emits the interceptor source code for all traced invocations.
    /// </summary>
    public static string Emit(ImmutableArray<TracedInvocationInfo> invocations)
    {
        if (invocations.IsEmpty)
            return string.Empty;

        var sb = new StringBuilder();

        AppendFileHeader(sb);
        AppendUsings(sb);
        AppendInterceptsLocationAttribute(sb);
        AppendActivitySourcesClass(sb, invocations);
        AppendClassOpen(sb);
        AppendInterceptorMethods(sb, invocations);
        AppendClassClose(sb);

        return sb.ToString();
    }

    private static void AppendFileHeader(StringBuilder sb)
    {
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#pragma warning disable");
        sb.AppendLine();
    }

    private static void AppendUsings(StringBuilder sb)
    {
        sb.AppendLine("using System.Diagnostics;");
        sb.AppendLine();
    }

    private static void AppendInterceptsLocationAttribute(StringBuilder sb)
    {
        sb.AppendLine("""
                      namespace System.Runtime.CompilerServices
                      {
                          [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                          file sealed class InterceptsLocationAttribute(int version, string data) : global::System.Attribute;
                      }
                      """);
        sb.AppendLine();
    }

    /// <summary>
    ///     Maps original ActivitySource names to unique field names.
    ///     Thread-local to avoid issues with parallel compilation.
    /// </summary>
    [ThreadStatic]
    private static Dictionary<string, string>? s_activitySourceFieldNames;

    private static void AppendActivitySourcesClass(StringBuilder sb, ImmutableArray<TracedInvocationInfo> invocations)
    {
        // Collect unique ActivitySource names and create unique field names
        var activitySourceNames = invocations
            .Select(static i => i.ActivitySourceName)
            .Distinct(StringComparer.Ordinal)
            .OrderBy(static n => n, StringComparer.Ordinal)
            .ToList();

        // Build a mapping from original name to unique field name
        s_activitySourceFieldNames = new Dictionary<string, string>(StringComparer.Ordinal);
        var usedFieldNames = new HashSet<string>(StringComparer.Ordinal);

        foreach (var name in activitySourceNames)
        {
            var baseFieldName = SanitizeFieldName(name);
            var fieldName = baseFieldName;
            var counter = 1;

            // Ensure uniqueness
            while (!usedFieldNames.Add(fieldName))
            {
                fieldName = $"{baseFieldName}_{counter++}";
            }

            s_activitySourceFieldNames[name] = fieldName;
        }

        sb.AppendLine("namespace Qyl.ServiceDefaults.Generator");
        sb.AppendLine("{");
        sb.AppendLine("    file static class TracedActivitySources");
        sb.AppendLine("    {");

        foreach (var name in activitySourceNames)
        {
            var fieldName = s_activitySourceFieldNames[name];
            sb.AppendLine($"        internal static readonly global::System.Diagnostics.ActivitySource {fieldName} = new(\"{name}\");");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");
        sb.AppendLine();
    }

    private static string GetActivitySourceFieldName(string activitySourceName)
    {
        return s_activitySourceFieldNames?.TryGetValue(activitySourceName, out var fieldName) == true
            ? fieldName
            : SanitizeFieldName(activitySourceName);
    }

    private static string SanitizeFieldName(string activitySourceName)
    {
        // Convert "MyApp.Orders" to "MyApp_Orders"
        var sanitized = new StringBuilder();
        foreach (var c in activitySourceName)
        {
            sanitized.Append(char.IsLetterOrDigit(c) ? c : '_');
        }
        return sanitized.ToString();
    }

    private static void AppendClassOpen(StringBuilder sb)
    {
        sb.AppendLine("""
                      namespace Qyl.ServiceDefaults.Generator
                      {
                          file static class TracedInterceptors
                          {
                      """);
    }

    private static void AppendInterceptorMethods(
        StringBuilder sb,
        ImmutableArray<TracedInvocationInfo> invocations)
    {
        var orderedInvocations = invocations
            .OrderBy(static i => i.OrderKey, StringComparer.Ordinal);

        var index = 0;
        foreach (var invocation in orderedInvocations)
        {
            AppendSingleInterceptor(sb, invocation, index);
            index++;
        }
    }

    private static void AppendSingleInterceptor(
        StringBuilder sb,
        TracedInvocationInfo invocation,
        int index)
    {
        var displayLocation = invocation.InterceptableLocation.GetDisplayLocation();
        var interceptAttribute = invocation.InterceptableLocation.GetInterceptsLocationAttributeSyntax();

        var methodName = $"Intercept_Traced_{index}";
        var typeParamNames = GetTypeParameterNames(invocation);
        var returnType = ToGlobalTypeName(invocation.ReturnTypeName, typeParamNames);
        var containingType = invocation.ContainingTypeName;
        var originalMethod = invocation.MethodName;
        var activitySourceField = GetActivitySourceFieldName(invocation.ActivitySourceName);

        var typeParams = BuildTypeParameterList(invocation);
        var constraints = BuildConstraintClauses(invocation);
        var parameters = BuildParameterList(invocation, containingType, typeParamNames);
        var arguments = BuildArgumentList(invocation);
        var tagSetters = BuildTagSetters(invocation);
        var methodCall = invocation.IsStatic
            ? $"global::{containingType}.{originalMethod}{typeParams}({arguments})"
            : $"@this.{originalMethod}{typeParams}({arguments})";

        if (invocation.IsAsync)
        {
            EmitAsyncInterceptor(sb, invocation, methodName, typeParams, constraints, returnType, parameters,
                displayLocation, interceptAttribute, activitySourceField, tagSetters, methodCall);
        }
        else
        {
            EmitSyncInterceptor(sb, invocation, methodName, typeParams, constraints, returnType, parameters,
                displayLocation, interceptAttribute, activitySourceField, tagSetters, methodCall);
        }
    }

    private static void EmitAsyncInterceptor(
        StringBuilder sb,
        TracedInvocationInfo invocation,
        string methodName,
        string typeParams,
        string constraints,
        string returnType,
        string parameters,
        string displayLocation,
        string interceptAttribute,
        string activitySourceField,
        string tagSetters,
        string methodCall)
    {
        var hasReturnValue = !returnType.EndsWith("Task", StringComparison.Ordinal) &&
                            !returnType.EndsWith("ValueTask", StringComparison.Ordinal);

        sb.AppendLine($$"""
                // Intercepted call at {{displayLocation}}
                {{interceptAttribute}}
                public static async {{returnType}} {{methodName}}{{typeParams}}({{parameters}}){{constraints}}
                {
                    using var activity = TracedActivitySources.{{activitySourceField}}.StartActivity(
                        "{{invocation.SpanName}}",
                        global::System.Diagnostics.ActivityKind.{{invocation.SpanKind}});
        """);

        if (!string.IsNullOrEmpty(tagSetters))
        {
            sb.AppendLine();
            sb.AppendLine("            if (activity is not null)");
            sb.AppendLine("            {");
            sb.Append(tagSetters);
            sb.AppendLine("            }");
        }

        sb.AppendLine();

        sb.AppendLine(hasReturnValue
            ? $$"""
                            try
                            {
                                var result = await {{methodCall}};
                                activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Ok);
                                return result;
                            }
                            catch (global::System.Exception ex)
                            {
                                activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Error, ex.Message);
                                activity?.AddEvent(new global::System.Diagnostics.ActivityEvent("exception", tags: new global::System.Diagnostics.ActivityTagsCollection { { "exception.type", ex.GetType().FullName }, { "exception.message", ex.Message } }));
                                throw;
                            }
                        }

                """
            : $$"""
                            try
                            {
                                await {{methodCall}};
                                activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Ok);
                            }
                            catch (global::System.Exception ex)
                            {
                                activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Error, ex.Message);
                                activity?.AddEvent(new global::System.Diagnostics.ActivityEvent("exception", tags: new global::System.Diagnostics.ActivityTagsCollection { { "exception.type", ex.GetType().FullName }, { "exception.message", ex.Message } }));
                                throw;
                            }
                        }

                """);
    }

    private static void EmitSyncInterceptor(
        StringBuilder sb,
        TracedInvocationInfo invocation,
        string methodName,
        string typeParams,
        string constraints,
        string returnType,
        string parameters,
        string displayLocation,
        string interceptAttribute,
        string activitySourceField,
        string tagSetters,
        string methodCall)
    {
        var hasReturnValue = returnType != "void";

        sb.AppendLine($$"""
                // Intercepted call at {{displayLocation}}
                {{interceptAttribute}}
                public static {{returnType}} {{methodName}}{{typeParams}}({{parameters}}){{constraints}}
                {
                    using var activity = TracedActivitySources.{{activitySourceField}}.StartActivity(
                        "{{invocation.SpanName}}",
                        global::System.Diagnostics.ActivityKind.{{invocation.SpanKind}});
        """);

        if (!string.IsNullOrEmpty(tagSetters))
        {
            sb.AppendLine();
            sb.AppendLine("            if (activity is not null)");
            sb.AppendLine("            {");
            sb.Append(tagSetters);
            sb.AppendLine("            }");
        }

        sb.AppendLine();

        sb.AppendLine(hasReturnValue
            ? $$"""
                            try
                            {
                                var result = {{methodCall}};
                                activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Ok);
                                return result;
                            }
                            catch (global::System.Exception ex)
                            {
                                activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Error, ex.Message);
                                activity?.AddEvent(new global::System.Diagnostics.ActivityEvent("exception", tags: new global::System.Diagnostics.ActivityTagsCollection { { "exception.type", ex.GetType().FullName }, { "exception.message", ex.Message } }));
                                throw;
                            }
                        }

                """
            : $$"""
                            try
                            {
                                {{methodCall}};
                                activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Ok);
                            }
                            catch (global::System.Exception ex)
                            {
                                activity?.SetStatus(global::System.Diagnostics.ActivityStatusCode.Error, ex.Message);
                                activity?.AddEvent(new global::System.Diagnostics.ActivityEvent("exception", tags: new global::System.Diagnostics.ActivityTagsCollection { { "exception.type", ex.GetType().FullName }, { "exception.message", ex.Message } }));
                                throw;
                            }
                        }

                """);
    }

    private static string BuildParameterList(TracedInvocationInfo invocation, string containingType, IReadOnlyList<string>? typeParamNames = null)
    {
        var sb = new StringBuilder();

        // Static methods don't have a 'this' parameter
        if (!invocation.IsStatic)
        {
            sb.Append($"this global::{containingType} @this");
        }

        for (var i = 0; i < invocation.ParameterTypes.Count; i++)
        {
            if (sb.Length > 0)
                sb.Append(", ");
            var typeName = ToGlobalTypeName(invocation.ParameterTypes[i], typeParamNames);
            sb.Append($"{typeName} {invocation.ParameterNames[i]}");
        }

        return sb.ToString();
    }

    /// <summary>
    ///     Converts a type name to a fully qualified global:: format.
    ///     Handles C# keyword aliases, generics, and nullable types recursively.
    /// </summary>
    private static string ToGlobalTypeName(string typeName, IReadOnlyList<string>? typeParameterNames = null)
    {
        if (string.IsNullOrEmpty(typeName))
            return typeName;

        // Check if this is a type parameter (T, TResult, etc.)
        if (typeParameterNames is not null && typeParameterNames.Contains(typeName))
            return typeName;

        // Handle nullable reference types (trailing ?)
        if (typeName.EndsWith("?", StringComparison.Ordinal))
            return ToGlobalTypeName(typeName[..^1], typeParameterNames) + "?";

        // Handle generic types: Task<Order> or Dictionary<string, Order>
        var genericStart = typeName.IndexOf('<');
        if (genericStart > 0 && typeName.EndsWith(">", StringComparison.Ordinal))
        {
            var baseTypeName = typeName[..genericStart];
            var argsContent = typeName[(genericStart + 1)..^1];

            var args = ParseGenericArguments(argsContent);
            var qualifiedArgs = args.Select(a => ToGlobalTypeName(a, typeParameterNames));

            return $"{ToGlobalTypeName(baseTypeName, typeParameterNames)}<{string.Join(", ", qualifiedArgs)}>";
        }

        // Map C# keyword aliases to their BCL names
        var mapped = typeName switch
        {
            "string" => "System.String",
            "int" => "System.Int32",
            "long" => "System.Int64",
            "short" => "System.Int16",
            "byte" => "System.Byte",
            "sbyte" => "System.SByte",
            "uint" => "System.UInt32",
            "ulong" => "System.UInt64",
            "ushort" => "System.UInt16",
            "float" => "System.Single",
            "double" => "System.Double",
            "decimal" => "System.Decimal",
            "bool" => "System.Boolean",
            "char" => "System.Char",
            "object" => "System.Object",
            "void" => "void",
            _ => typeName
        };

        return mapped == "void" ? "void" : $"global::{mapped}";
    }

    /// <summary>
    ///     Parses generic type arguments, handling nested generics correctly.
    /// </summary>
    private static List<string> ParseGenericArguments(string argsContent)
    {
        var args = new List<string>();
        var depth = 0;
        var start = 0;

        for (var i = 0; i < argsContent.Length; i++)
        {
            switch (argsContent[i])
            {
                case '<':
                    depth++;
                    break;
                case '>':
                    depth--;
                    break;
                case ',' when depth == 0:
                    args.Add(argsContent[start..i].Trim());
                    start = i + 1;
                    break;
            }
        }

        if (start < argsContent.Length)
            args.Add(argsContent[start..].Trim());

        return args;
    }

    private static string BuildTypeParameterList(TracedInvocationInfo invocation)
    {
        if (invocation.TypeParameters.Count == 0)
            return "";

        return "<" + string.Join(", ", invocation.TypeParameters.Select(static tp => tp.Name)) + ">";
    }

    private static string BuildConstraintClauses(TracedInvocationInfo invocation)
    {
        var constraints = invocation.TypeParameters
            .Where(static tp => tp.Constraints is not null)
            .Select(static tp => tp.Constraints);

        var clauseList = constraints.ToList();
        return clauseList.Count > 0 ? " " + string.Join(" ", clauseList) : "";
    }

    private static IReadOnlyList<string> GetTypeParameterNames(TracedInvocationInfo invocation)
    {
        return [.. invocation.TypeParameters.Select(static tp => tp.Name)];
    }

    private static string BuildArgumentList(TracedInvocationInfo invocation)
    {
        return invocation.ParameterNames.Count is 0 ? string.Empty : string.Join(", ", invocation.ParameterNames);
    }

    private static string BuildTagSetters(TracedInvocationInfo invocation)
    {
        if (invocation.TracedTags.Count is 0)
            return string.Empty;

        var sb = new StringBuilder();

        foreach (var tag in invocation.TracedTags)
        {
            if (tag.SkipIfNull && tag.IsNullable)
            {
                sb.AppendLine($"                if ({tag.ParameterName} is not null)");
                sb.AppendLine($"                    activity.SetTag(\"{tag.TagName}\", {tag.ParameterName});");
            }
            else
            {
                sb.AppendLine($"                activity.SetTag(\"{tag.TagName}\", {tag.ParameterName});");
            }
        }

        return sb.ToString();
    }

    private static void AppendClassClose(StringBuilder sb)
    {
        sb.AppendLine("""
                          }
                      }
                      """);
    }
}
