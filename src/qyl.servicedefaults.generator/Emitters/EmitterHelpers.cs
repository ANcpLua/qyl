using ANcpLua.Roslyn.Utilities;

namespace Qyl.ServiceDefaults.Generator.Emitters;

/// <summary>
///     Shared helper methods for source emitters.
/// </summary>
internal static class EmitterHelpers
{
    /// <summary>
    ///     Appends the standard auto-generated file header.
    /// </summary>
    /// <param name="sb">StringBuilder to append to.</param>
    /// <param name="suppressWarnings">If true, adds #pragma warning disable.</param>
    /// <param name="nullableEnable">If true, adds #nullable enable.</param>
    public static void AppendFileHeader(StringBuilder sb, bool suppressWarnings = false, bool nullableEnable = false)
    {
        sb.AppendLine("// <auto-generated/>");

        if (suppressWarnings)
            sb.AppendLine("#pragma warning disable");

        if (nullableEnable)
            sb.AppendLine(GeneratedCodeHelpers.NullableEnable);

        sb.AppendLine();
    }

    /// <summary>
    ///     Appends the file-scoped InterceptsLocationAttribute required for C# interceptors.
    ///     This attribute is defined as file-scoped to avoid conflicts with other generators.
    /// </summary>
    public static void AppendInterceptsLocationAttribute(StringBuilder sb)
    {
        sb.AppendLine("""
                      namespace System.Runtime.CompilerServices
                      {
                          [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                          file sealed class InterceptsLocationAttribute(int version, string data) : global::System.Attribute;
                      }
                      """);
        sb.AppendLine();
    }

    /// <summary>
    ///     Appends closing braces for nested namespace and class.
    /// </summary>
    public static void AppendClassClose(StringBuilder sb)
    {
        sb.AppendLine("""
                          }
                      }
                      """);
    }

    /// <summary>
    ///     Builds the parameter list for an interceptor method signature.
    /// </summary>
    /// <param name="containingType">The fully-qualified type name of the intercepted method's class.</param>
    /// <param name="parameterTypes">The parameter type names.</param>
    /// <param name="parameterNames">The parameter names (used in the signature).</param>
    /// <param name="isStatic">If true, omits the <c>this</c> parameter.</param>
    /// <param name="typeParamNames">Optional type parameter names for global type name resolution.</param>
    public static string BuildParameterList(
        string containingType,
        IReadOnlyList<string> parameterTypes,
        IReadOnlyList<string> parameterNames,
        bool isStatic = false,
        IReadOnlyList<string>? typeParamNames = null)
    {
        var sb = new StringBuilder();

        if (!isStatic)
            sb.Append($"this global::{containingType} @this");

        for (var i = 0; i < parameterTypes.Count; i++)
        {
            if (sb.Length > 0)
                sb.Append(", ");
            var typeName = parameterTypes[i].ToGlobalTypeName(typeParamNames);
            sb.Append($"{typeName} {parameterNames[i]}");
        }

        return sb.ToString();
    }

    /// <summary>
    ///     Builds the argument list for forwarding to the original method.
    /// </summary>
    public static string BuildArgumentList(IReadOnlyList<string> parameterNames)
    {
        return parameterNames.Count is 0 ? string.Empty : string.Join(", ", parameterNames);
    }

    /// <summary>
    ///     Checks if a type name represents a primitive value type.
    /// </summary>
    public static bool IsPrimitiveValueType(string typeName)
    {
        return typeName.StartsWithOrdinal("global::System.Int") ||
               typeName.StartsWithOrdinal("global::System.UInt") ||
               typeName.StartsWithOrdinal("global::System.Double") ||
               typeName.StartsWithOrdinal("global::System.Single") ||
               typeName.StartsWithOrdinal("global::System.Decimal") ||
               typeName.StartsWithOrdinal("global::System.Boolean") ||
               typeName.StartsWithOrdinal("global::System.Byte") ||
               typeName.StartsWithOrdinal("global::System.SByte") ||
               typeName.StartsWithOrdinal("global::System.Char") ||
               typeName.StartsWithOrdinal("global::System.DateTime") ||
               typeName.StartsWithOrdinal("global::System.TimeSpan") ||
               typeName.StartsWithOrdinal("global::System.Guid") ||
               typeName is "int" or "uint" or "long" or "ulong" or "short" or "ushort" or
                   "byte" or "sbyte" or "float" or "double" or "decimal" or "bool" or "char";
    }
}
