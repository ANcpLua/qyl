using ANcpLua.Roslyn.Utilities;

namespace Qyl.ServiceDefaults.Generator.Emitters;

/// <summary>
///     Shared helper methods for source emitters.
/// </summary>
internal static class EmitterHelpers
{
    /// <summary>
    ///     Appends the standard auto-generated file header.
    /// </summary>
    /// <param name="sb">StringBuilder to append to.</param>
    /// <param name="suppressWarnings">If true, adds #pragma warning disable.</param>
    /// <param name="nullableEnable">If true, adds #nullable enable.</param>
    public static void AppendFileHeader(StringBuilder sb, bool suppressWarnings = false, bool nullableEnable = false)
    {
        sb.AppendLine("// <auto-generated/>");

        if (suppressWarnings)
            sb.AppendLine("#pragma warning disable");

        if (nullableEnable)
            sb.AppendLine(GeneratedCodeHelpers.NullableEnable);

        sb.AppendLine();
    }

    /// <summary>
    ///     Appends the file-scoped InterceptsLocationAttribute required for C# interceptors.
    ///     This attribute is defined as file-scoped to avoid conflicts with other generators.
    /// </summary>
    public static void AppendInterceptsLocationAttribute(StringBuilder sb)
    {
        sb.AppendLine("""
                      namespace System.Runtime.CompilerServices
                      {
                          [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                          file sealed class InterceptsLocationAttribute(int version, string data) : global::System.Attribute;
                      }
                      """);
        sb.AppendLine();
    }

    /// <summary>
    ///     Appends closing braces for nested namespace and class.
    /// </summary>
    public static void AppendClassClose(StringBuilder sb)
    {
        sb.AppendLine("""
                          }
                      }
                      """);
    }

    /// <summary>
    ///     Escapes a type name for use in generated code.
    ///     Primitive type aliases (string, int, etc.) cannot be prefixed with global::
    ///     Handles arrays, nullable types, and generic types.
    /// </summary>
    public static string ToGlobalTypeName(string typeName)
    {
        if (string.IsNullOrEmpty(typeName))
            return typeName;

        // Handle array types (e.g., "string[]", "int[][]")
        if (typeName.EndsWithOrdinal("[]"))
        {
            var elementType = typeName[..^2];
            return ToGlobalTypeName(elementType) + "[]";
        }

        // Handle nullable reference types (trailing ?)
        if (typeName.EndsWithOrdinal("?") &&
            !IsPrimitiveKeyword(typeName[..^1]))
        {
            return ToGlobalTypeName(typeName[..^1]) + "?";
        }

        // Handle generic types: Task<Order> or Dictionary<string, Order>
        var genericStart = typeName.IndexOf('<');
        if (genericStart > 0 && typeName.EndsWithOrdinal(">"))
        {
            var baseTypeName = typeName[..genericStart];
            var argsContent = typeName[(genericStart + 1)..^1];

            var args = ParseGenericArguments(argsContent);
            var qualifiedArgs = args.Select(ToGlobalTypeName);

            return $"{ToGlobalTypeName(baseTypeName)}<{string.Join(", ", qualifiedArgs)}>";
        }

        // Primitive type aliases don't need global:: prefix
        return typeName switch
        {
            "string" or "string?" => typeName,
            "bool" or "bool?" => typeName,
            "byte" or "byte?" => typeName,
            "sbyte" or "sbyte?" => typeName,
            "short" or "short?" => typeName,
            "ushort" or "ushort?" => typeName,
            "int" or "int?" => typeName,
            "uint" or "uint?" => typeName,
            "long" or "long?" => typeName,
            "ulong" or "ulong?" => typeName,
            "float" or "float?" => typeName,
            "double" or "double?" => typeName,
            "decimal" or "decimal?" => typeName,
            "char" or "char?" => typeName,
            "object" or "object?" => typeName,
            "void" => "void",
            _ => $"global::{typeName}"
        };
    }

    /// <summary>
    ///     Checks if a type name is a C# primitive keyword.
    /// </summary>
    private static bool IsPrimitiveKeyword(string typeName)
    {
        return typeName is "string" or "bool" or "byte" or "sbyte" or "short" or "ushort"
            or "int" or "uint" or "long" or "ulong" or "float" or "double"
            or "decimal" or "char" or "object" or "void";
    }

    /// <summary>
    ///     Parses generic type arguments, handling nested generics correctly.
    /// </summary>
    private static List<string> ParseGenericArguments(string argsContent)
    {
        var args = new List<string>();
        var depth = 0;
        var start = 0;

        for (var i = 0; i < argsContent.Length; i++)
            switch (argsContent[i])
            {
                case '<':
                    depth++;
                    break;
                case '>':
                    depth--;
                    break;
                case ',' when depth is 0:
                    args.Add(argsContent[start..i].Trim());
                    start = i + 1;
                    break;
            }

        if (start < argsContent.Length)
            args.Add(argsContent[start..].Trim());

        return args;
    }

    /// <summary>
    ///     Checks if a type name represents a primitive value type.
    /// </summary>
    public static bool IsPrimitiveValueType(string typeName)
    {
        return typeName.StartsWithOrdinal("global::System.Int") ||
               typeName.StartsWithOrdinal("global::System.UInt") ||
               typeName.StartsWithOrdinal("global::System.Double") ||
               typeName.StartsWithOrdinal("global::System.Single") ||
               typeName.StartsWithOrdinal("global::System.Decimal") ||
               typeName.StartsWithOrdinal("global::System.Boolean") ||
               typeName.StartsWithOrdinal("global::System.Byte") ||
               typeName.StartsWithOrdinal("global::System.SByte") ||
               typeName.StartsWithOrdinal("global::System.Char") ||
               typeName.StartsWithOrdinal("global::System.DateTime") ||
               typeName.StartsWithOrdinal("global::System.TimeSpan") ||
               typeName.StartsWithOrdinal("global::System.Guid") ||
               typeName is "int" or "uint" or "long" or "ulong" or "short" or "ushort" or
                   "byte" or "sbyte" or "float" or "double" or "decimal" or "bool" or "char";
    }
}
