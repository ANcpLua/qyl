using System.Text;

namespace Qyl.ServiceDefaults.Generator.Emitters;

/// <summary>
///     Shared helper methods for source emitters.
/// </summary>
internal static class EmitterHelpers
{
    /// <summary>
    ///     Appends the standard auto-generated file header.
    /// </summary>
    /// <param name="sb">StringBuilder to append to.</param>
    /// <param name="suppressWarnings">If true, adds #pragma warning disable.</param>
    /// <param name="nullableEnable">If true, adds #nullable enable.</param>
    public static void AppendFileHeader(StringBuilder sb, bool suppressWarnings = false, bool nullableEnable = false)
    {
        sb.AppendLine("// <auto-generated/>");

        if (suppressWarnings)
            sb.AppendLine("#pragma warning disable");

        if (nullableEnable)
            sb.AppendLine("#nullable enable");

        sb.AppendLine();
    }

    /// <summary>
    ///     Appends the file-scoped InterceptsLocationAttribute required for C# interceptors.
    ///     This attribute is defined as file-scoped to avoid conflicts with other generators.
    /// </summary>
    public static void AppendInterceptsLocationAttribute(StringBuilder sb)
    {
        sb.AppendLine("""
                      namespace System.Runtime.CompilerServices
                      {
                          [global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
                          file sealed class InterceptsLocationAttribute(int version, string data) : global::System.Attribute;
                      }
                      """);
        sb.AppendLine();
    }

    /// <summary>
    ///     Appends closing braces for nested namespace and class.
    /// </summary>
    public static void AppendClassClose(StringBuilder sb)
    {
        sb.AppendLine("""
                          }
                      }
                      """);
    }

    /// <summary>
    ///     Escapes a type name for use in generated code.
    ///     Primitive type aliases (string, int, etc.) cannot be prefixed with global::
    /// </summary>
    public static string ToGlobalTypeName(string typeName)
    {
        // Primitive type aliases don't need global:: prefix
        return typeName switch
        {
            "string" or "string?" => typeName,
            "bool" or "bool?" => typeName,
            "byte" or "byte?" => typeName,
            "sbyte" or "sbyte?" => typeName,
            "short" or "short?" => typeName,
            "ushort" or "ushort?" => typeName,
            "int" or "int?" => typeName,
            "uint" or "uint?" => typeName,
            "long" or "long?" => typeName,
            "ulong" or "ulong?" => typeName,
            "float" or "float?" => typeName,
            "double" or "double?" => typeName,
            "decimal" or "decimal?" => typeName,
            "char" or "char?" => typeName,
            "object" or "object?" => typeName,
            "void" => "void",
            _ => $"global::{typeName}"
        };
    }

    /// <summary>
    ///     Checks if a type name represents a primitive value type.
    /// </summary>
    public static bool IsPrimitiveValueType(string typeName) =>
        typeName.StartsWith("global::System.Int", StringComparison.Ordinal) ||
        typeName.StartsWith("global::System.UInt", StringComparison.Ordinal) ||
        typeName.StartsWith("global::System.Double", StringComparison.Ordinal) ||
        typeName.StartsWith("global::System.Single", StringComparison.Ordinal) ||
        typeName.StartsWith("global::System.Decimal", StringComparison.Ordinal) ||
        typeName.StartsWith("global::System.Boolean", StringComparison.Ordinal) ||
        typeName.StartsWith("global::System.Byte", StringComparison.Ordinal) ||
        typeName.StartsWith("global::System.SByte", StringComparison.Ordinal) ||
        typeName.StartsWith("global::System.Char", StringComparison.Ordinal) ||
        typeName.StartsWith("global::System.DateTime", StringComparison.Ordinal) ||
        typeName.StartsWith("global::System.TimeSpan", StringComparison.Ordinal) ||
        typeName.StartsWith("global::System.Guid", StringComparison.Ordinal) ||
        typeName is "int" or "uint" or "long" or "ulong" or "short" or "ushort" or
                    "byte" or "sbyte" or "float" or "double" or "decimal" or "bool" or "char";
}
